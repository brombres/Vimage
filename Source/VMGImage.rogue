uses Bitmap

class VMGImage
  PROPERTIES
    file        : File?
    bitmap      : Bitmap
    name        : String
    zoom        : Real64
    view_center = RealXY(0.5,0.5)
    is_modified : Logical

    cached_text_canvas    : TextCanvas
    cached_bitmap_size    : XY
    cached_view_center    : XY
    cached_display_bounds : Box

  METHODS
    method init( bitmap, name=null )

    method init( bitmap, file )
      if (file) name = file.value.filepath

    method init( file )
      if local bitmap = Bitmap( file.value )
        init( bitmap, file.value.filepath )
      else
        init( Bitmap(16,16), file.value.filepath )
      endIf

    method init( info:Value )
      if (info//filepath) file = File(info//filepath->String)
      bitmap = info//bitmap.to<<Bitmap>>
      name = which{ info//name:info//name->String || null }
      zoom = info//zoom
      view_center = XY( info//view_center//x, info//view_center//y )
      is_modified = info//is_modified

      cached_text_canvas = null

    method cloned_bitmap->Bitmap
      # Editing commands operate on copies of bitmap objects for undo chain purposes.
      bitmap .= cloned
      return bitmap

    method compact_name->String
      local dims = "[$x$]"(bitmap.width,bitmap.height)
      if (@name)
        local brief_name = File(@name).filename.before_last('.')
        return "$ $"(brief_name,dims)
      endIf
      return dims

    method text_canvas( bitmap_size:XY, display_bounds:Box )->TextCanvas
      if (cached_text_canvas and bitmap_size == cached_bitmap_size and display_bounds == cached_display_bounds and
          view_center == cached_view_center)
        return cached_text_canvas
      endIf

      cached_bitmap_size = bitmap_size
      cached_display_bounds = display_bounds
      cached_view_center = view_center

      local canvas_size = bitmap_size / XY(1,2)

      local canvas_bounds = Box( (display_bounds.size/2-(canvas_size*view_center)).clamped_high(XY.zero), canvas_size )
      canvas_bounds .= clamped( Box(display_bounds.size) )
      local bitmap_bounds = canvas_bounds * XY(1,2)
      local piece_size = ((display_bounds.size * XY(1,2) / zoom) + XY(0.5,0.5))->XY.clamped_high( bitmap.size )
      if ((piece_size.y * zoom)->Int32 & 1)
        local new_piece_size = ((piece_size * zoom) + XY(0,1)) / zoom
        local piece_bounds = Box( -bitmap_bounds.position/zoom, new_piece_size )
        if local intersection = piece_bounds & Box(bitmap.size)
          if intersection == piece_bounds
            piece_size = new_piece_size
          endIf
        endIf
      endIf
      local piece = Bitmap( bitmap, Box(-bitmap_bounds.position/zoom,piece_size) )
      piece.resize( piece_size*zoom )
      cached_text_canvas = ANSIBitmap( piece )->TextCanvas( &bg=CharacterStyle.BG_DEFAULT )
      return cached_text_canvas

    method to->String
      local dims = "[$x$]"(bitmap.width,bitmap.height)
      if (name) return "$ $"(name,dims)
      return dims

    method to->Value
      return ...
      @{
        filepath:which{file:file.value.filepath||null},
        bitmap:Value(bitmap),
        :name,
        :zoom,
        view_center:{x:view_center.x,y:view_center.y},
        :is_modified
      }
endClass

