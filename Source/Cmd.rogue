library Vimage
uses Math/Best
uses Math/PerlinNoise

class Cmd
  GLOBAL METHODS
    method create( new_state:State )->Cmd
      return CmdChangeState( new_state )

    method create( callback:Function(e:KeyEvent) )->Cmd
      return CmdCallback( callback )

  METHODS
    method init

    method allowed_in_macro->Logical
      return true

    method call
      update_status
      if (Vimage.repeat_count)
        local repeat_count = Vimage.read_and_reset_repeat_count
        execute( repeat_count )
      else
        execute( 1 )
      endIf

    method execute
      noAction

    method execute( repeat_count:Int )
      loop (repeat_count)
        execute
      endLoop

    method is_edit->Logical
      return false

    method is_interactive->Logical
      return false

    method on( e:KeyEvent )
      Vimage.execute( this )

    method set_state( new_state:State )
      State.current.change_state( new_state )

    method set_status( text:String, &dim )
      use status = StatusBar
        if (dim) status.style.dim
        status.print text
        if (dim) status.style.dim_off
      endUse

    method update_status
      noAction
endClass

class EditCmd : Cmd
  METHODS
    method is_edit->Logical
      return true

    method call
      update_status
      if (Vimage.repeat_count)
        local repeat_count = Vimage.read_and_reset_repeat_count
        execute( repeat_count )
        Vimage.last_repeat_count = repeat_count
      else
        execute( 1 )
        Vimage.last_repeat_count = 1
      endIf

endClass

class InteractiveCmd : Cmd
  METHODS
    method is_interactive->Logical
      return true
endClass

class CmdCallback( callback:Function(e:KeyEvent) ) : Cmd
  METHODS
    method on( e:KeyEvent )
      callback( e )
endClass

class CmdChangeState( new_state:State ) : InteractiveCmd
  METHODS
    method on( e:KeyEvent )
      state = new_state
endClass

class CmdApply : EditCmd [singleton]
  METHODS
    method allowed_in_macro->Logical
      return false

    method update_status
      if (Vimage.recording_macro)
        Vimage.recording_macro = false
        if (Vimage.macro.count) status = "a (apply macro) [recording stopped]"
        else                    status = "a (apply macro) [recording stopped] [no macro recorded]"
      elseIf (Vimage.macro.is_empty)
        status = "a (apply macro) [no macro recorded]"
      else
        status = "a (apply macro)"
      endIf

    method execute
      forEach (cmd in Vimage.macro) Vimage.execute( cmd, &skip_undo_save_state )
      Vimage.last_cmd = this
endClass

class CmdApplyAll : EditCmd [singleton]
  METHODS
    method allowed_in_macro->Logical
      return false

    method update_status
      if (Vimage.recording_macro)
        Vimage.recording_macro = false
        if (Vimage.macro.count) status = "A (apply macro to all) [recording stopped]"
        else                    status = "A (apply macro to all) [recording stopped] [no macro recorded]"
      elseIf (Vimage.macro.is_empty)
        status = "a (apply macro to all) [no macro recorded]"
      else
        status = "a (apply macro to all)"
      endIf

    method execute
      VimageUI.actions += ActionApplyAll( this )
endClass

class CmdAspect( size:XY ) : EditCmd
  METHODS
    method update_status
      use status = StatusBar
        status.print "crop to have aspect ratio "
        status.print size.x
        status.print ':'
        status.print size.y
        if (not ImageList.selected) status.print " [no image selected]"
      endUse

    method execute
      if (not ImageList.selected) return
      execute( ImageList.selected.image )

    method execute( image:Image )
      local w = image.bitmap.width
      local h = image.bitmap.height
      local adjusted_height = (w->Real / size.x) * size.y : Int
      local adjusted_width  = (h->Real / size.y) * size.x : Int
      if (adjusted_width == w and adjusted_height == h) return

      local bitmap = image.cloned_bitmap
      if (adjusted_width < w) bitmap.crop( adjusted_width, h,  Vimage.anchor, Vimage.bg_color )
      else                    bitmap.crop( w, adjusted_height, Vimage.anchor, Vimage.bg_color )

      ImageView.show( image )
endClass

class CmdBeginCommandLine : InteractiveCmd [singleton]
  METHODS
    method update_status
      use builder = StatusBar
        builder.print ':'
        builder.style.inverse; builder.print ' '; builder.style.inverse_off
      endUse

    method on( e:KeyEvent )
      Vimage.repeat_count = null
      VimageUI.command.clear
      update_status
      state = EnterCmdLineState()
endClass

class CmdBitwiseAND : EditCmd [singleton]
  METHODS
    method update_status
      status = "& (bitwise-AND with underlying image)"

    method execute
      if local selected = ImageList.selected
        if (selected is ImageList.last_child)
          status = "& (bitwise-AND) [no underlying image]"
          return
        else
          local top    = selected.image.bitmap
          local bottom_image  = selected.next->(as ImageListItem).image
          local bottom_bitmap = bottom_image.cloned_bitmap
          top.blit( bottom_bitmap, XY(0,0), BlitModeAND )
          ImageList.remove( selected )
          ImageList.select( bottom_image )
        endIf
      endIf
endClass

class CmdAdd : EditCmd [singleton]
  METHODS
    method update_status
      status = "+ (add to underlying image)"

    method execute
      if local selected = ImageList.selected
        if (selected is ImageList.last_child)
          status = "+ (add) [no underlying image]"
          return
        else
          local top    = selected.image.bitmap
          local bottom_image  = selected.next->(as ImageListItem).image
          local bottom_bitmap = bottom_image.cloned_bitmap
          top.blit( bottom_bitmap, XY(0,0), BlitModeAdd )
          ImageList.remove( selected )
          ImageList.select( bottom_image )
        endIf
      endIf
endClass

class CmdMultiply : EditCmd [singleton]
  METHODS
    method update_status
      status = "* (multiply with underlying image)"

    method execute
      if local selected = ImageList.selected
        if (selected is ImageList.last_child)
          status = "* (multiply) [no underlying image]"
          return
        else
          local top    = selected.image.bitmap
          local bottom_image  = selected.next->(as ImageListItem).image
          local bottom_bitmap = bottom_image.cloned_bitmap
          top.blit( bottom_bitmap, XY(0,0), BlitModeMultiply )
          ImageList.remove( selected )
          ImageList.select( bottom_image )
        endIf
      endIf
endClass

class CmdBitwiseOR : EditCmd [singleton]
  METHODS
    method update_status
      status = "| (bitwise-OR with underlying image)"

    method execute
      if local selected = ImageList.selected
        if (selected is ImageList.last_child)
          status = "| (bitwise-OR) [no underlying image]"
          return
        else
          local top    = selected.image.bitmap
          local bottom_image  = selected.next->(as ImageListItem).image
          local bottom_bitmap = bottom_image.cloned_bitmap
          top.blit( bottom_bitmap, XY(0,0), BlitModeOR )
          ImageList.remove( selected )
          ImageList.select( bottom_image )
        endIf
      endIf
endClass

class CmdBitwiseXOR : EditCmd [singleton]
  METHODS
    method update_status
      status = "~ (bitwise-XOR with underlying image)"

    method execute
      if local selected = ImageList.selected
        if (selected is ImageList.last_child)
          status = "~ (bitwise-XOR) [no underlying image]"
          return
        else
          local top    = selected.image.bitmap
          local bottom_image  = selected.next->(as ImageListItem).image
          local bottom_bitmap = bottom_image.cloned_bitmap
          top.blit( bottom_bitmap, XY(0,0), BlitModeXOR )
          ImageList.remove( selected )
          ImageList.select( bottom_image )
        endIf
      endIf
endClass

class CmdBitwiseNOT : EditCmd [singleton]
  METHODS
    method update_status
      status = "! (bitwise-NOT; invert)"

    method execute
      if local selected = ImageList.selected
        local bitmap = selected.image.cloned_bitmap
        local n = bitmap.pixels.count
        native @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;
                |
                |while (--$n >= 0)
                |{
                |  RogueInt32 argb = *(++data);
                |  *data = (argb & 0xFF000000) | (~argb & 0xFFffFF);
                |}
      endIf
endClass

class CmdBitwiseRotateLeft : EditCmd [singleton]
  METHODS
    method update_status
      status = "< (bitwise rotate left)"

    method execute
      if local selected = ImageList.selected
        local bitmap = selected.image.cloned_bitmap
        local n = bitmap.size.product
        native @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;
                |
                |while (--$n >= 0)
                |{
                |  RogueInt32 argb = *(++data);
                |  *data = (argb & 0xFF000000) | ((argb<<1) & 0xFFffFE) | ((argb>>23) & 1);
                |}
      endIf
endClass

class CmdBitwiseRotateRight : EditCmd [singleton]
  METHODS
    method update_status
      status = "> (bitwise rotate right)"

    method execute
      if local selected = ImageList.selected
        local bitmap = selected.image.cloned_bitmap
        local n = bitmap.size.product
        native @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;
                |
                |while (--$n >= 0)
                |{
                |  RogueInt32 argb = *(++data);
                |  *data = (argb & 0xFF000000) | ((argb>>1) & 0x7FffFF) | ((argb<<23) & 0x800000);
                |}
      endIf
endClass

class CmdCrop( left:Int, top:Int, right:Int, bottom:Int ) : EditCmd
  METHODS
    method update_status
      local status = String()
      local n = which{ Vimage.repeat_count || 1 }

      localize left, top, right, bottom
      left *= n
      top *= n
      right *= n
      bottom *= n

      status.print( "crop" )
      if (left)   status.print " left $"(left)
      if (top)    status.print " top $"(top)
      if (right)  status.print " right $"(right)
      if (bottom) status.print " bottom $"(bottom)

      if local selected = ImageList.selected
        local size = selected.image.bitmap.size
        if (size.x - (left+right) < 1 or size.y - (top+bottom) < 1)
          status.print " [exceeds image dimensions]"
        endIf
      else
        status.print " [no image selected]"
      endIf

      StatusBar.text = status

    method execute( repeat_count:Int )
      if (not ImageList.selected) return
      execute( ImageList.selected.image, repeat_count )

    method execute( image:Image, n:Int )
      localize left, top, right, bottom
      left *= n
      top *= n
      right *= n
      bottom *= n

      if (image.size.x - (left+right) < 1 or image.size.y - (top+bottom) < 1)
        return
      endIf

      image.cloned_bitmap.crop( left, top, right, bottom, Vimage.bg_color )
      ImageView.show( image )
endClass

class CmdCropToSize( size:Size, anchor=null:Anchor? ) : EditCmd
  METHODS
    method update_status
      use status = StatusBar
        status.print "crop "
        if (size.x and size.y)
          status.print "$x$"(size.x,size.y)
        elseIf (size.x)
          status.print "width $"(size.x)
        elseIf (size.y)
          status.print "height $"(size.y)
        endIf
        if (not ImageList.selected) status.print " [no image selected]"
      endUse

    method execute
      if (not ImageList.selected) return
      execute( ImageList.selected.image )

    method execute( image:Image )
      local anchor = which{ anchor || Vimage.anchor }
      temporarily Vimage.anchor = anchor
        if (size.x)
          local width = size->XY.x
          if (width < 0) width = image.bitmap.width + width

          if (size.y)
            local height = size->XY.y
            if (height < 0) height = image.bitmap.height + height
            if (image.bitmap.size == XY(width,height)) return

            local bitmap = image.cloned_bitmap
            bitmap.crop( width, height, anchor, Vimage.bg_color )
          else
            local new_size = XY( width, image.bitmap.height )
            if (image.bitmap.size == new_size) return

            local bitmap = image.cloned_bitmap
            bitmap.crop( new_size.x, new_size.y, anchor, Vimage.bg_color )
          endIf
        elseIf (size.y)
          local height = size->XY.y
          if (height < 0) height = image.bitmap.height + height
          local new_size = XY( image.bitmap.width, height )
          if (image.bitmap.size == new_size) return

          local bitmap = image.cloned_bitmap
          bitmap.crop( new_size.x, new_size.y, anchor, Vimage.bg_color )
        endIf
      endTemporarily

      ImageView.show( image )
endClass

class CmdCropToScale( sx:Real?, sy:Real?, anchor=null:Anchor? ) : EditCmd
  METHODS
    method update_status
      use status = StatusBar
        status.print "crop to scale "
        if (sx and sy)
          status.print "$x$"(sx,sy)
        elseIf (sx)
          status.print "sx $"(sx)
        elseIf (sy)
          status.print "sy $"(sy)
        endIf
        if (not ImageList.selected) status.print " [no image selected]"
      endUse

    method execute
      if (not ImageList.selected) return
      execute( ImageList.selected.image )

    method execute( image:Image )
      local w, h : Int?
      if (sx) w = (image.bitmap.width  * sx.value)->Int
      if (sy) h = (image.bitmap.height * sy.value)->Int
      CmdCropToSize( Size(w,h), anchor ).execute
endClass

class CmdDX : EditCmd [singleton]
  METHODS
    method on( e:KeyEvent )
endClass

class CmdDelete : EditCmd [singleton]
  METHODS
    method update_status
      if (ImageList.selected)
        set_status( "d (delete image and copy to clipboard)" )
      else
        set_status( "d [no image to delete]" )
      endIf

    method execute( repeat_count:Int )
      loop (repeat_count-1)
        if (ImageList.selected)
          ImageList.remove_selected
        endIf
      endLoop

      if (ImageList.selected)
        if (Vimage.using_os_clipboard)
          Clipboard.bitmap = ImageList.selected->(as ImageListItem).image.bitmap
        endIf
        Vimage.clipboard = ImageList.selected->(as ImageListItem).image.bitmap
        Vimage.clipboard_file = ImageList.selected->(as ImageListItem).image.file
        ImageList.remove_selected
      endIf
endClass

class CmdEscapeToImageListState : Cmd [singleton]
  METHODS
    method execute
      state = ImageListState
endClass

class CmdGoToFirstImage : Cmd [singleton]
  METHODS
    method update_status
      status = "g (go to first image)"

    method execute
      if (ImageList.count)
        ImageList.select( 0 )
      endIf
endClass

class CmdGoToLastImage : Cmd [singleton]
  METHODS
    method update_status
      status = "G (go to last image)"

    method execute
      if (ImageList.count)
        ImageList.select( ImageList.count-1 )
      endIf
endClass

class CmdImageListNext : Cmd [singleton]
  METHODS
    method update_status
      status = "j (down to next image)"

    method execute
      if local current = ImageList.selected
        if (current.next)
          ImageList.select( current.next->(as ImageListItem) )
        endIf
      endIf
endClass

class CmdImageListPrevious : Cmd [singleton]
  METHODS
    method update_status
      status = "k (up to previous image)"

    method execute
      if local current = ImageList.selected
        forEach (child in ImageList.children)
          if (child.next is current)
            ImageList.select( child->(as ImageListItem) )
            escapeForEach
          endIf
        endForEach
      endIf
endClass

class CmdImageListShiftDown : Cmd [singleton]
  METHODS
    method update_status
      status = "J (shift image down in list)"

    method execute
      if local current = ImageList.selected
        if local index = ImageList.locate( current )
          Vimage.save_undo
          ImageList.remove( current )
          ImageList.insert( current, index+1 )
          ImageList.request_layout
        endIf
      endIf
endClass

class CmdImageListShiftUp : Cmd [singleton]
  METHODS
    method update_status
      status = "K (shift image up in list)"

    method execute
      if local current = ImageList.selected
        if local index = ImageList.locate( current )
          if (index > 0)
            Vimage.save_undo
            ImageList.remove( current )
            ImageList.insert( current, index-1 )
            ImageList.request_layout
          endIf
        endIf
      endIf
endClass

class CmdPanToBottom : Cmd [singleton]
  METHODS
    method update_status
      status = "G (go to bottom)"

    method execute
      if local item = ImageList.selected
        item.image.camera = XY( item.image.camera.x, 1.0 )
        ImageView.mark_modified
      endIf
endClass

class CmdPanToLeft : Cmd [singleton]
  METHODS
    method update_status
      status = "# (scroll to left side)"

    method execute
      if local item = ImageList.selected
        item.image.camera .= yv
        ImageView.mark_modified
      endIf
endClass

class CmdPanToLeftAndEnterZoomMode : Cmd [singleton]
  METHODS
    method execute
      if local item = ImageList.selected
        item.image.camera .= yv
        ImageView.mark_modified
        if (State.current is not ZoomState and item.image.zoom != ImageView.default_zoom)
          State.change_state( ZoomState )
        endIf
      endIf
endClass

class CmdPanToRight : Cmd [singleton]
  METHODS
    method update_status
      status = "$ (scroll to right side)"

    method execute
      if local item = ImageList.selected
        item.image.camera = XY( 1.0, item.image.camera.y )
        ImageView.mark_modified
      endIf
endClass

class CmdPanToRightAndEnterZoomMode : Cmd [singleton]
  METHODS
    method execute
      if local item = ImageList.selected
        item.image.camera = XY( 1.0, item.image.camera.y )
        ImageView.mark_modified
        if (State.current is not ZoomState and item.image.zoom != ImageView.default_zoom)
          State.change_state( ZoomState )
        endIf
      endIf
endClass

class CmdPanToTop : Cmd [singleton]
  METHODS
    method update_status
      status = "g (go to top)"

    method execute
      if local item = ImageList.selected
        item.image.camera .= xv
        ImageView.mark_modified
      endIf
endClass

class CmdParseJoinH : Cmd [singleton]
  METHODS
    method on( e:KeyEvent )
      local cmd = CmdJoin( XY( which{Vimage.repeat_count||2}, 1 ) )
      Vimage.repeat_count = null
      Vimage.execute( cmd )
endClass

class CmdParseJoinV : Cmd [singleton]
  METHODS
    method on( e:KeyEvent )
      local cmd = CmdJoin( XY( 1, which{Vimage.repeat_count||2} ) )
      Vimage.repeat_count = null
      Vimage.execute( cmd )
endClass

class CmdJoin( dims:XY, patch=false:Logical, blend=0.0:Real, blend_wrap=false:Logical ) : EditCmd
  DEFINITIONS
    OPAQUE      = Color( 0xFFFFFFFF )
    TRANSPARENT = Color( 0x00FFFFFF )

  PROPERTIES
    cur_color : Color
    alt_color : Color

  METHODS
    method update_status
      local w = dims.x->Int
      local h = dims.y->Int
      local total = w * h
      local has_images = which{ ImageList.count:"" || " [no image selected]" }
      if (total <= 1)
        status = "join $x$ [no effect]"(w,h)
        return
      elseIf (h == 1 and not patch and not blend)
        if (w == 2) status = "n (join horizontal)$"(has_images)
        else        status = "$n (join horizontal)$"(w,has_images)
      elseIf (w == 1 and not patch and not blend)
        if (h == 2) status = "N (join vertical)$"(has_images)
        else        status = "$N (join vertical)$"(h,has_images)
      else
        local message = "join $x$"(w,h)
        if (patch) message .= appending( "patch" )
        if (blend)
          message .= appending( "blend" )
          if (blend > 1.0) message .= appending( "$ pixels"(blend->Int-1) )
          else             message .= appending( "$%"(blend.format(".0%")) )
          if (blend_wrap) message .= appending( "wrap" )
        endIf

        if (ImageList.count == 0) message .= appending( "[no image selected]" )

        status = message
      endIf

    method execute
      local w = dims.x->Int
      local h = dims.y->Int
      local total = w * h

      if (ImageList.count == 0 or total <= 1) return

      local original_index = ImageList.selected.index

      use list = WorkList<<Image>>
        loop (total)
          local index = ImageList.selected.index
          list.add( ImageList.selected.image )
          ImageList.remove( ImageList.selected )
          if (index < ImageList.count)
            ImageList.select( index )
          elseIf (ImageList.count > 0)
            ImageList.select( ImageList.last_child->(as ImageListItem) )
            escapeLoop
          else
            ImageList.select( null )
            escapeLoop
          endIf
        endLoop

        local file : File?
        forEach (image in list)
          if (image.file)
            file = image.file
            escapeForEach
          endIf
        endForEach

        if (file)
          local ext = file.value.extension
          local filepath = file.value.filepath
          local existing_suffix = filepath.extract_string( "*-$(I).$"('$',ext) )
          if (existing_suffix)
            filepath = "$.$"(filepath.before_last("-"+existing_suffix),ext)
          else
            existing_suffix = filepath.extract_string( "*_$(I).$"('$',ext) )
            if (existing_suffix)
              filepath = "$.$"(filepath.before_last("_"+existing_suffix),ext)
            endIf
          endIf

          file = ImageList.make_filepath_unique( File(filepath) )
        endIf

        while (list.count < total)
          list.add( Image(Bitmap(1,1).[clear(Vimage.bg_color)]) )
        endWhile

        local max_width = Best<<Int>>( (a,b) => a > b )
        local max_height = Best<<Int>>( (a,b) => a > b )

        local total_w, total_h : Int
        if (w == 1)
          # Resize all images to be max width
          max_width.consider( (forEach in list).bitmap.width )
          local tile_w = max_width.value

          local cmd = CmdResizeToSize( Size(tile_w,undefined) )
          cmd.execute( (forEach in list) )
          total_w = tile_w
          total_h += (forEach in list).bitmap.height
        elseIf (h == 1)
          # Resize all images to be max height
          max_height.consider( (forEach in list).bitmap.height )
          local tile_h = max_height.value

          local cmd = CmdResizeToSize( Size(undefined,tile_h) )
          cmd.execute( (forEach in list) )
          total_w += (forEach in list).bitmap.width
          total_h = tile_h
        else
          # Add image padding as necessary to ensure that all images
          # on a row are the same height and that all rows are the
          # same width.
          forEach (j in 0..<h)
            max_height.clear

            local row_w = 0
            forEach (i in 0..<w)
              local bitmap = list[ j*w+i ].bitmap
              max_height.consider( bitmap.height )
              row_w += bitmap.width
            endForEach
            max_width.consider( row_w )
            total_h += max_height.value

            forEach (i in 0..<w)
              local image = list[ j*w+i ]
              local dh = max_height.value - image.bitmap.height
              if (dh > 0) image.cloned_bitmap.expand( 0, 0, 0, dh )
            endForEach
          endForEach

          total_w = max_width.value

          # Ensure each row is max_width
          forEach (j in 0..<h)
            local row_w = 0
            forEach (i in 0..<w)
              row_w += list[j*w+i].bitmap.width
            endForEach

            local dw = max_width.value - row_w
            if (dw > 0)
              list[(j+1)*w - 1].cloned_bitmap.expand( 0, 0, dw, 0 )
            endIf
          endForEach
        endIf

        local result_bitmap : Bitmap

        if (blend)
          result_bitmap = .execute_blend_join( list, w, h )
        else
          result_bitmap = .execute_standard_join( list, w, h )
        endIf

        local result_image = Image( result_bitmap, file ).[ is_modified=true ]
        ImageList.insert( result_image, original_index )
        ImageList.select( result_image )
      endUse

    method .execute_blend_join( list:Image[], w:Int, h:Int )->Bitmap
      local tiles = Bitmap[]
      tiles.add( (forEach in list).cloned_bitmap )

      # Blend-join horizontal tiles in each row
      local rows = Bitmap[]
      forEach (j in 0..<h)
        local first_w = tiles[ j*w ].width
        local last_w  = tiles[ (j+1)*w - 1 ].width
        local row_bitmap : Bitmap
        local prev_w : Int
        forEach (i in 0..<w)
          local cur_bitmap = tiles[ j*w + i ]
          local cur_w = cur_bitmap.width
          if (i == 0)
            row_bitmap = cur_bitmap
          else
            row_bitmap = .blend_horizontal(
              row_bitmap,
              prev_w,
              cur_bitmap,
              cur_w,
              blend
            )
          endIf
          prev_w = cur_w
        endForEach

        if (blend_wrap and w > 1)
          local original_w = row_bitmap.width
          row_bitmap = .blend_horizontal(
            row_bitmap,
            last_w,
            row_bitmap.cloned,
            first_w,
            blend
          )
          local overlap_w = (original_w + original_w) - row_bitmap.width
          local overlap_bitmap = Bitmap( row_bitmap, Box(original_w-overlap_w/2,0,overlap_w/2,row_bitmap.height) )
          overlap_bitmap.blit( row_bitmap, overlap_w/2, 0 )
          row_bitmap.crop( overlap_w/2, 0, overlap_w/2, 0 )
          row_bitmap.crop( row_bitmap.width/2, row_bitmap.height, Anchor.LEFT )
        endIf

        rows.add( row_bitmap )
      endForEach

      # Blend-join rows vertically
      local first_h = rows.first.height
      local last_h  = rows.last.height
      local result_bitmap : Bitmap
      local prev_h : Int
      forEach (j in 0..<h)
        local cur_bitmap = rows[j]
        local cur_h = cur_bitmap.height
        if (j == 0)
          result_bitmap = cur_bitmap
        else
          result_bitmap = .blend_vertical(
            result_bitmap,
            prev_h,
            cur_bitmap,
            cur_h,
            blend
          )
        endIf
        prev_h = cur_h
      endForEach

      if (blend_wrap and h > 1)
        local original_h = result_bitmap.height
        result_bitmap = .blend_vertical(
          result_bitmap,
          last_h,
          result_bitmap.cloned,
          first_h,
          blend
        )
        local overlap_h = (original_h + original_h) - result_bitmap.height
        local overlap_bitmap = Bitmap( result_bitmap, Box(0,original_h-overlap_h/2,result_bitmap.width,overlap_h/2) )
        overlap_bitmap.blit( result_bitmap, 0, overlap_h/2 )
        result_bitmap.crop( 0, overlap_h/2, 0, overlap_h/2 )
        result_bitmap.crop( result_bitmap.width, result_bitmap.height/2, Anchor.TOP )
      endIf

      return result_bitmap

    method .blend_horizontal( left:Bitmap, left_blend_w:Int, right:Bitmap, right_blend_w:Int, blend:Real )->Bitmap
      local min_width = left_blend_w.or_smaller( right_blend_w )
      local overlap_w : Int
      if (blend > 1.0) overlap_w = blend->Int - 1
      else             overlap_w = (min_width * blend)->Int
      local result_w = (left.width + right.width) - overlap_w

      if (left_blend_w <= right_blend_w)
        left.fill(
          Box( XY(left.width-overlap_w,0), XY(overlap_w,left.height) ),
          Graphics::ColorGradient( OPAQUE, TRANSPARENT, OPAQUE, TRANSPARENT ),
          &fn=ColorGradientMultiplyBitmapFillFn,
          &channel_mask=0xFF000000
        )
        left.crop( result_w, left.height, Anchor.LEFT )
        right.crop( result_w, right.height, Anchor.RIGHT )
        left.blit( right, 0, 0, BitmapBlitFn.ALPHA )
        return right
      else
        right.fill(
          Box( XY(overlap_w,right.height) ),
          Graphics::ColorGradient( TRANSPARENT, OPAQUE, TRANSPARENT, OPAQUE ),
          &fn=ColorGradientMultiplyBitmapFillFn,
          &channel_mask=0xFF000000
        )
        left.crop( result_w,  left.height, Anchor.LEFT )
        right.crop( result_w, right.height, Anchor.RIGHT )
        right.blit( left, 0, 0, BitmapBlitFn.ALPHA )
        return left
      endIf

    method .blend_vertical( top:Bitmap, top_blend_h:Int, bottom:Bitmap, bottom_blend_h:Int, blend:Real )->Bitmap
      local min_height = top_blend_h.or_smaller( bottom_blend_h )
      local overlap_h : Int
      if (blend > 1.0) overlap_h = blend->Int - 1
      else             overlap_h = (min_height * blend)->Int
      local result_h = (top.height + bottom.height) - overlap_h

      if (top_blend_h <= bottom_blend_h)
        top.fill(
        Box( XY(0,top.height-overlap_h), XY(top.width,overlap_h) ),
          Graphics::ColorGradient( OPAQUE, OPAQUE, TRANSPARENT, TRANSPARENT ),
          &fn=ColorGradientMultiplyBitmapFillFn,
          &channel_mask=0xFF000000
        )
        top.crop( top.width, result_h, Anchor.TOP )
        bottom.crop( bottom.width, result_h, Anchor.BOTTOM )
        top.blit( bottom, 0, 0, BitmapBlitFn.ALPHA )
        return bottom
      else
        bottom.fill(
          Box( XY(overlap_h,bottom.width) ),
          Graphics::ColorGradient( TRANSPARENT, OPAQUE, TRANSPARENT, OPAQUE ),
          &fn=ColorGradientMultiplyBitmapFillFn,
          &channel_mask=0xFF000000
        )
        top.crop( top.width, result_h, Anchor.TOP )
        bottom.crop( bottom.width, result_h, Anchor.BOTTOM )
        bottom.blit( top, 0, 0, BitmapBlitFn.ALPHA )
        return top
      endIf

    method .execute_standard_join( list:Image[], w:Int, h:Int )->Bitmap
      # Determine total_w and total_h
      local total_w = 0
      local total_h = 0
      total_w += list[forEach in 0..<w].bitmap.width
      total_h += list[(forEach in 0..<h)*w].bitmap.height

      local result = Bitmap( total_w, total_h )
      local cursor_y = 0L
      forEach (j in 0..<h)
        local cursor_x = 0L
        local dy : Int
        forEach (i in 0..<w)
          local bitmap = list[ j*w+i ].bitmap
          bitmap.blit( result, cursor_x, cursor_y )
          dy = bitmap.height
          cursor_x += bitmap.width
        endForEach
        cursor_y += dy
      endForEach

      if (patch)
        cur_color = Color.RED
        alt_color = Color.GREEN
        if (h == 1)
          # Only a top size strip (font characters)
          local top = .create_h_size_strip( list, w, h, total_w )
          local work = Bitmap( total_w, total_h + 1 )
          top.blit( work, 0, 0 )
          result.blit( work, 0, 1 )
          result = work
        else
          # Size strips on all sides
          local top   = .create_h_size_strip( list, w, h, total_w, &corners )
          swapValues( cur_color, alt_color )
          local right = .create_v_size_strip( list, w, h, total_h )

          cur_color = Color.RED
          alt_color = Color.GREEN
          local left   = .create_v_size_strip( list, w, h, total_h )
          swapValues( cur_color, alt_color )
          local bottom = .create_h_size_strip( list, w, h, total_w, &corners )

          local work = Bitmap( total_w+2, total_h+2 )
          top.blit( work, 0, 0 )
          bottom.blit( work, 0, total_h+1 )
          left.blit( work, 0, 1 )
          right.blit( work, total_w+1, 1 )
          result.blit( work, 1, 1 )
          result = work
        endIf
      endIf

      return result

    method .create_h_size_strip( list:Image[], w:Int, h:Int, total_w:Int, &corners )->Bitmap
      local strip_w = total_w
      if (corners) strip_w += 2
      local strip = Bitmap( strip_w, 1 )

      local pixels = strip.pixels
      local pos = 0
      if (corners)
        pixels[0] = cur_color
        pos = 1
      endIf

      forEach (i in 0..<w)
        local bitmap = list[i].bitmap
        loop (bitmap.width)
          pixels[pos] = cur_color
          ++pos
        endLoop
        swapValues( cur_color, alt_color )
      endForEach

      if (corners) pixels[pos] = alt_color

      return strip

    method .create_v_size_strip( list:Image[], w:Int, h:Int, total_h:Int )->Bitmap
      local strip = Bitmap( 1, total_h )
      block
        local pixels = strip.pixels
        local pos = 0
        forEach (j in 0..<h)
          local bitmap = list[j*w].bitmap
          loop (bitmap.height)
            pixels[pos] = cur_color
            ++pos
          endLoop
          swapValues( cur_color, alt_color )
        endForEach
      endBlock
      return strip
endClass

class CmdAspectFillToSize( size:Size ) : EditCmd
  METHODS
    method update_status
      use status = StatusBar
        status.print "aspect-fill (resize to fill) "
        if (size.x and size.y)
          status.print "$x$"(size.x,size.y)
        elseIf (size.x)
          status.print "width $"(size.x)
        elseIf (size.y)
          status.print "height $"(size.y)
        endIf
        if (not ImageList.selected) status.print " [no image selected]"
      endUse

    method execute
      if (not ImageList.selected) return
      execute( ImageList.selected.image )

    method execute( image:Image )
      if (size.x)
        local width = size->XY.x
        if (size.y)
          local height = size->XY.y
          if (image.bitmap.size == XY(width,height)) return

          local bitmap = image.cloned_bitmap
          local x_scale = width->Real / image.bitmap.width
          local y_scale = height->Real / image.bitmap.height
          local scale = x_scale.or_larger( y_scale )
          bitmap.resize( bitmap.size * scale )
          bitmap.crop( width, height, Vimage.anchor, Vimage.bg_color )
        else
          local new_size = XY( width, image.bitmap.size.y*(width->Real/image.bitmap.width) )
          if (image.bitmap.size == new_size) return

          local bitmap = image.cloned_bitmap
          bitmap.resize( new_size.x, new_size.y )
        endIf
      elseIf (size.y)
        local height = size->XY.y
        local new_size = XY( image.bitmap.size.x*(height->Real/image.bitmap.size.y), height )
        if (image.bitmap.size == new_size) return

        local bitmap = image.cloned_bitmap
        bitmap.resize( new_size.x, new_size.y )
      endIf

      ImageView.show( image )
endClass

class CmdAspectFillToScale( sx:Real?, sy:Real? ) : EditCmd
  METHODS
    method update_status
      use status = StatusBar
        status.print "aspect-fill to scale "
        if (sx and sy)
          status.print "$x$"(sx,sy)
        elseIf (sx)
          status.print "sx $"(sx)
        elseIf (sy)
          status.print "sy $"(sy)
        endIf
        if (not ImageList.selected) status.print " [no image selected]"
      endUse

    method execute
      if (not ImageList.selected) return
      execute( ImageList.selected.image )

    method execute( image:Image )
      local w, h : Int?
      if (sx) w = (image.bitmap.width  * sx.value)->Int
      if (sy) h = (image.bitmap.height * sy.value)->Int
      CmdAspectFillToSize( Size(w,h) ).execute
endClass

class CmdAspectFitToSize( size:Size ) : EditCmd
  METHODS
    method update_status
      use status = StatusBar
        status.print "aspect-fit (resize to fit) "
        if (size.x and size.y)
          status.print "$x$"(size.x,size.y)
        elseIf (size.x)
          status.print "width $"(size.x)
        elseIf (size.y)
          status.print "height $"(size.y)
        endIf
        if (not ImageList.selected) status.print " [no image selected]"
      endUse

    method execute
      if (not ImageList.selected) return
      execute( ImageList.selected.image )

    method execute( image:Image )
      if (size.x)
        local width = size->XY.x
        if (size.y)
          local height = size->XY.y
          if (image.bitmap.size == XY(width,height)) return

          local bitmap = image.cloned_bitmap
          local x_scale = width->Real / image.bitmap.size.x
          local y_scale = height->Real / image.bitmap.size.y
          local scale = x_scale.or_smaller( y_scale )
          bitmap.resize( bitmap.size * scale )
          bitmap.crop( width, height, Vimage.anchor, Vimage.bg_color )
        else
          local new_size = XY( width, image.bitmap.size.y*(width->Real/image.bitmap.size.x) )
          if (image.bitmap.size == new_size) return

          local bitmap = image.cloned_bitmap
          bitmap.resize( new_size.x, new_size.y )
        endIf
      elseIf (size.y)
        local height = size->XY.y
        local new_size = XY( image.bitmap.size.x*(height->Real/image.bitmap.size.y), height )
        if (image.bitmap.size == new_size) return

        local bitmap = image.cloned_bitmap
        bitmap.resize( new_size.x, new_size.y )
      endIf

      ImageView.show( image )
endClass

class CmdAspectFitToScale( sx:Real?, sy:Real? ) : EditCmd
  METHODS
    method update_status
      use status = StatusBar
        status.print "aspect-fit to scale "
        if (sx and sy)
          status.print "$x$"(sx,sy)
        elseIf (sx)
          status.print "sx $"(sx)
        elseIf (sy)
          status.print "sy $"(sy)
        endIf
        if (not ImageList.selected) status.print " [no image selected]"
      endUse

    method execute
      if (not ImageList.selected) return
      execute( ImageList.selected.image )

    method execute( image:Image )
      local w, h : Int?
      if (sx) w = (image.bitmap.width  * sx.value)->Int
      if (sy) h = (image.bitmap.height * sy.value)->Int
      CmdAspectFitToSize( Size(w,h) ).execute
endClass

class CmdFilterClamp( lo:ColorValue, hi:ColorValue ) : EditCmd
  METHODS
    method update_status
      use status = StatusBar
        status.print "filter clamp $ $"(lo,hi)
        if (not ImageList.selected)
          status.print " [no image selected]"
        endIf
      endUse

    method execute
      if local selected = ImageList.selected
        local bitmap = selected.image.cloned_bitmap
        local n = bitmap.size.product
        local lo = lo->Color
        local hi = hi->Color
        local min_a = lo.alpha_byte
        local min_r = lo.red_byte
        local min_g = lo.green_byte
        local min_b = lo.blue_byte
        local max_a = hi.alpha_byte
        local max_r = hi.red_byte
        local max_g = hi.green_byte
        local max_b = hi.blue_byte
        native @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;
                |
                |while (--$n >= 0)
                |{
                |  RogueInt32 argb = *(++data);
                |  int a = (argb >> 24) & 255;
                |  int r = (argb >> 16) & 255;
                |  int g = (argb >> 8) & 255;
                |  int b = argb & 255;
                |  a = (a < $min_a) ? $min_a : (a > $max_a ? $max_a : a);
                |  r = (r < $min_r) ? $min_r : (r > $max_r ? $max_r : r);
                |  g = (g < $min_g) ? $min_g : (g > $max_g ? $max_g : g);
                |  b = (b < $min_b) ? $min_b : (b > $max_b ? $max_b : b);
                |  *data = (a<<24) | (r<<16) | (g<<8) | b;
                |}
      endIf
endClass

class CmdChannelCopy( a:String, b:String ) : EditCmd
  METHODS
    method update_status
      if (not ImageList.selected)
        status = "channel copy channel $ -> channels $ [no image selected]"(a,b)
        return
      endIf

      status = "channel copy channel $ -> channels $"(a,b)

    method execute
      if (not ImageList.selected)
        return
      endIf

      local bitmap = ImageList.selected.image.cloned_bitmap

      if (a.count == 1 and "bgra".contains(a))
        local a_shift = ("bgra".locate(a).value :<<: 3)
        forEach (dest_channel in b)
          local b_shift = ("bgra".locate(dest_channel).value :<<: 3)
          forEach (color in rewriter=bitmap.pixels.rewriter)
            local a = (color.argb :>>>: a_shift) & 0xFF
            local b = (color.argb :>>>: b_shift) & 0xFF
            local argb = color.argb & !(0xFF:<<:b_shift)
            argb |= (a :<<: b_shift)
            rewriter.write( Color(argb) )
          endForEach
        endForEach
      else
        # Replace color channel with constant value 00-ff
        local a = a->Int(&base=16)
        forEach (dest_channel in b)
          local b_shift = ("bgra".locate(dest_channel).value :<<: 3)
          local write_a = a :<<: b_shift
          forEach (color in rewriter=bitmap.pixels.rewriter)
            local argb = color.argb & !(0xFF:<<:b_shift)
            argb |= write_a
            rewriter.write( Color(argb) )
          endForEach
        endForEach
      endIf

      ImageView.mark_modified
endClass

class CmdExtract( min:Int[], max:Int[] ) : EditCmd
  METHODS
    method update_status
      status = "extract color range"

    method execute
      if local current = ImageList.selected
        if local index = ImageList.locate( current )
          local bitmap = Bitmap( current.image.bitmap.size )
          current.image.bitmap.blit( bitmap, 0, 0, BlitModeExtract(min,max) )
          local image = Image( bitmap )
          ImageList.insert( image, index )
          ImageList.select( index )
          ImageList.request_layout
        endIf
      else
        status = "extract color range [no image selected]"
      endIf
endClass

class CmdFlipH : EditCmd [singleton]
  METHODS
    method update_status
      if (ImageList.selected)
        status = "f (flip horizontal)"
      else
        status = "f (flip horizontal) [no image selected]"
      endIf

    method execute
      if (ImageList.selected)
        local img = ImageList.selected.image
        img.cloned_bitmap.flip( &h )
        ImageView.mark_modified
      endIf
endClass

class CmdFlipV : EditCmd [singleton]
  METHODS
    method update_status
      if (ImageList.selected)
        status = "F (flip vertical)"
      else
        status = "F (flip vertical) [no image selected]"
      endIf

    method execute
      if (ImageList.selected)
        local img = ImageList.selected.image
        img.cloned_bitmap.flip( &v )
        ImageView.mark_modified
      endIf
endClass

class CmdFill( c:ColorValue ) : EditCmd
  METHODS
    method update_status
      status = "fill $"(c)

    method execute( ignore_repeat_count:Int )
      if (not ImageList.selected) return

      local bitmap = ImageList.selected.image.cloned_bitmap
      local w = bitmap.width
      local h = bitmap.height
      local color = c->Color.argb

      native @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;

      loop (h)
        local n = w
        native
          @|while (--$n >= 0)
           |{
           |  *(++data) = $color;
           |}
      endLoop

endClass

class CmdFill2( a:ColorValue, b:ColorValue ) : EditCmd METHODS
    method update_status
      status = "fill $ $"(a,b)

    method execute( ignore_repeat_count:Int )
      CmdFill4( a, a, b, b ).execute( &=ignore_repeat_count )

endClass

class CmdFill4( a:ColorValue, b:ColorValue, c:ColorValue, d:ColorValue ) : EditCmd
  METHODS
    method update_status
      status = "fill $ $ $ $"(a,b,c,d)

    method execute( ignore_repeat_count:Int )
      if (not ImageList.selected) return

      local bitmap = ImageList.selected.image.cloned_bitmap
      local w = bitmap.width
      local h = bitmap.height
      local left = ColorLerp( a, c, h-1 )
      local right = ColorLerp( b, d, h-1 )

      native @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;

      loop (h)
        local mid = ColorLerp( Color(left.read_another.value), Color(right.read_another.value), w-1 )
        local n = w
        native
          @|while (--$n >= 0)
           |{
              local argb = mid.read_another.value
        native
          @|  *(++data) = $argb;
           |}
      endLoop

endClass

class CmdFillGradient( colors:ColorValue[] ) : EditCmd
  METHODS
    method update_status
      status = "fill $"(colors)

    method execute( ignore_repeat_count:Int )
      if (not ImageList.selected) return

      local bitmap = ImageList.selected.image.cloned_bitmap
      local w = bitmap.width
      local h = bitmap.height
      local gradient = ColorGradient( colors, w )

      native @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;

      loop (h)
        gradient.reset
        local n = w
        native
          @|while (--$n >= 0)
           |{
              local argb = gradient.read_another.value
        native
          @|  *(++data) = $argb;
           |}
      endLoop

endClass

class CmdFillAlpha( c:ColorValue ) : EditCmd
  METHODS
    method update_status
      status = "fillalpha $"(c)

    method execute( ignore_repeat_count:Int )
      if (not ImageList.selected) return

      local bitmap = ImageList.selected.image.cloned_bitmap
      local w = bitmap.width
      local h = bitmap.height
      local color = c->Color.argb & 0xFF000000;

      native @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;

      loop (h)
        local n = w
        native
          @|while (--$n >= 0)
           |{
           |  RogueInt32 existing = *(++data);
           |  *data = (existing & 0x00FFFFFF) | $color;
           |}
      endLoop

endClass

class CmdFillAlpha2( a:ColorValue, b:ColorValue ) : EditCmd METHODS
    method update_status
      status = "fillalpha $ $"(a,b)

    method execute( ignore_repeat_count:Int )
      CmdFillAlpha4( a, a, b, b ).execute( &=ignore_repeat_count )

endClass

class CmdFillAlpha4( a:ColorValue, b:ColorValue, c:ColorValue, d:ColorValue ) : EditCmd
  METHODS
    method update_status
      status = "fillalpha $ $ $ $"(a,b,c,d)

    method execute( ignore_repeat_count:Int )
      if (not ImageList.selected) return

      local bitmap = ImageList.selected.image.cloned_bitmap
      local w = bitmap.width
      local h = bitmap.height
      local left = ColorLerp( a, c, h-1 )
      local right = ColorLerp( b, d, h-1 )

      native @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;

      loop (h)
        local mid = ColorLerp( Color(left.read_another.value), Color(right.read_another.value), w-1 )
        local n = w
        native
          @|while (--$n >= 0)
           |{
              local argb = mid.read_another.value
        native
          @|  RogueInt32 color = *(++data);
           |  *data = (color & 0x00FFFFFF) | ($argb & 0xFF000000);
           |}
      endLoop

endClass

class CmdFillAlphaGradient( colors:ColorValue[] ) : EditCmd
  METHODS
    method update_status
      status = "fillalpha $"(colors)

    method execute( ignore_repeat_count:Int )
      if (not ImageList.selected) return

      local bitmap = ImageList.selected.image.cloned_bitmap
      local w = bitmap.width
      local h = bitmap.height
      local gradient = ColorGradient( colors, w )

      native @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;

      loop (h)
        gradient.reset
        local n = w
        native
          @|while (--$n >= 0)
           |{
              local argb = gradient.read_another.value
        native
          @|  RogueInt32 color = *(++data);
           |  *data = (color & 0x00FFFFFF) | ($argb & 0xFF000000);
           |}
      endLoop

endClass

class CmdFillRGB( c:ColorValue ) : EditCmd
  METHODS
    method update_status
      status = "fillrgb $"(c)

    method execute( ignore_repeat_count:Int )
      if (not ImageList.selected) return

      local bitmap = ImageList.selected.image.cloned_bitmap
      local w = bitmap.width
      local h = bitmap.height
      local color = c->Color.argb & 0x00FFFFFF;

      native @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;

      loop (h)
        local n = w
        native
          @|while (--$n >= 0)
           |{
           |  RogueInt32 existing = *(++data);
           |  *data = (existing & 0xFF000000) | $color;
           |}
      endLoop

endClass

class CmdFillRGB2( a:ColorValue, b:ColorValue ) : EditCmd METHODS
    method update_status
      status = "fillrgb $ $"(a,b)

    method execute( ignore_repeat_count:Int )
      CmdFillRGB4( a, a, b, b ).execute( &=ignore_repeat_count )

endClass

class CmdFillRGB4( a:ColorValue, b:ColorValue, c:ColorValue, d:ColorValue ) : EditCmd
  METHODS
    method update_status
      status = "fillrgb $ $ $ $"(a,b,c,d)

    method execute( ignore_repeat_count:Int )
      if (not ImageList.selected) return

      local bitmap = ImageList.selected.image.cloned_bitmap
      local w = bitmap.width
      local h = bitmap.height
      local left = ColorLerp( a, c, h-1 )
      local right = ColorLerp( b, d, h-1 )

      native @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;

      loop (h)
        local mid = ColorLerp( Color(left.read_another.value), Color(right.read_another.value), w-1 )
        local n = w
        native
          @|while (--$n >= 0)
           |{
              local argb = mid.read_another.value
        native
          @|  RogueInt32 color = *(++data);
           |  *data = (color & 0xFF000000) | ($argb & 0x00FFFFFF);
           |}
      endLoop

endClass

class CmdFillRGBGradient( colors:ColorValue[] ) : EditCmd
  METHODS
    method update_status
      status = "fillrgb $"(colors)

    method execute( ignore_repeat_count:Int )
      if (not ImageList.selected) return

      local bitmap = ImageList.selected.image.cloned_bitmap
      local w = bitmap.width
      local h = bitmap.height
      local gradient = ColorGradient( colors, w )

      native @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;

      loop (h)
        gradient.reset
        local n = w
        native
          @|while (--$n >= 0)
           |{
              local argb = gradient.read_another.value
        native
          @|  RogueInt32 color = *(++data);
           |  *data = (color & 0xFF000000) | ($argb & 0x00FFFFFF);
           |}
      endLoop

endClass


class CmdFilterBrightGold( args:String[] ) : EditCmd
  METHODS
    method update_status
      status = "filter brightgold".appending(args.join(" "))

    method execute( ignore_repeat_count:Int )
      if (not ImageList.selected) return

      local bitmap = ImageList.selected.image.cloned_bitmap
      native @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;

      loop (bitmap.width * bitmap.height)
        local color = Color( native("*(++data)")->Int )

        # Save alpha
        local alpha = (color.argb & 0xff00_0000)

        # Grayscale value 'v' is the max of all color components
        local v = (color.argb:>>>:16) & 0xff
        v .= or_larger( (color.argb:>>>:8) & 0xff )
        v .= or_larger( color.argb & 0xff )

        if (v >= 255*2/3)
          # Top 33% grayscale: yellow to white
          color = ((v/255.0 - 2.0/3.0) * 3).lerp( Color.YELLOW, Color.WHITE )
        elseIf (v >= 255*1/3)
          # Middle 33% grayscale: orange to yellow
          color = ((v/255.0 - 1.0/3.0) * 3).lerp( Color.ORANGE, Color.YELLOW )
        else
          # Bottom 33% grayscale: black to orange
          color = (v/255.0 * 3).lerp( Color.BLACK, Color.ORANGE )
        endIf

        # Write gold value back with original alpha
        native @|*data = $alpha | ($color.argb & 0x00ffffff);
      endLoop
endClass


class CmdFilterGold( args:String[] ) : EditCmd
  METHODS
    method update_status
      status = "filter gold".appending(args.join(" "))

    method execute( ignore_repeat_count:Int )
      if (not ImageList.selected) return

      local bitmap = ImageList.selected.image.cloned_bitmap
      native @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;

      loop (bitmap.width * bitmap.height)
        local color = Color( native("*(++data)")->Int )

        # Save alpha
        local alpha = (color.argb & 0xff00_0000)

        # Compute grayscale value 'v'
        local v = (((color.argb:>>>:16) & 0xff) * 30) / 100  # 30% red
        v += (((color.argb:>>>:8) & 0xff) * 58) / 100        # 58% green
        v += ((color.argb & 0xff) * 11) / 100                # 11% blue

        if (v >= 255*2/3)
          # Top 33% grayscale: yellow to white
          color = ((v/255.0 - 2.0/3.0) * 3).lerp( Color.YELLOW, Color.WHITE )
        elseIf (v >= 255*1/3)
          # Middle 33% grayscale: orange to yellow
          color = ((v/255.0 - 1.0/3.0) * 3).lerp( Color.ORANGE, Color.YELLOW )
        else
          # Bottom 33% grayscale: black to orange
          color = (v/255.0 * 3).lerp( Color.BLACK, Color.ORANGE )
        endIf

        # Write gold value back with original alpha
        native @|*data = $alpha | ($color.argb & 0x00ffffff);
      endLoop

endClass


class CmdFilterMatchBright( args:String[] ) : EditCmd
  METHODS
    method update_status
      use status = StatusBar
        status.print "filter matchbright"
        if (not ImageList.selected)
          status.print " [no image selected]"
        elseIf (not ImageList.selected.next)
          status.print " [no underlying image to match]"
        endIf
      endUse

    method execute( ignore_repeat_count:Int )
      if (not ImageList.selected) return
      if (not ImageList.selected.next) return

      local bitmap = ImageList.selected.image.bitmap.cloned
      local bottom = ImageList.selected.next->(as ImageListItem).image.bitmap.cloned

      # Grayscale conversion factors
      local rw = (0.2990 * 65536)->Int
      local gw = (0.5870 * 65536)->Int
      local bw = (0.1140 * 65536)->Int

      local avg_over_value = 0.0
      block n = 0
        forEach (color in bitmap.pixels)
          if ((color.argb & 0xFF000000) >= 0x40)
            local r = (color.argb:>>>:16) & 0xff
            local g = (color.argb:>>>:8)  & 0xff
            local b =  color.argb         & 0xff
            local v = (r * rw) :>>: 16
            v += (g * gw) :>>: 16
            v += (b * bw) :>>: 16
            avg_over_value += v
            ++n
          endIf
        endForEach
        avg_over_value /= n.or_larger(1)
      endBlock

      local avg_under_value = 0.0
      block n = 0
        forEach (color in bottom.pixels)
          if ((color.argb & 0xFF000000) >= 0x40)
            local r = (color.argb:>>>:16) & 0xff
            local g = (color.argb:>>>:8)  & 0xff
            local b =  color.argb         & 0xff
            local v = (r * rw) :>>: 16
            v += (g * gw) :>>: 16
            v += (b * bw) :>>: 16
            avg_under_value += v
            ++n
          endIf
        endForEach
        avg_under_value /= n.or_larger(1)
      endBlock

      local v_scale_gray = avg_under_value / avg_over_value.or_larger(1)

      CmdChannelRGBToHSV.convert_rgb_to_hsv( bitmap )
      CmdChannelRGBToHSV.convert_rgb_to_hsv( bottom )

      avg_over_value = 0.0
      block n = 0
        forEach (color in bitmap.pixels)
          if ((color.argb & 0xFF000000) >= 0x40)
            avg_over_value += color.argb & 0xFF
            ++n
          endIf
        endForEach
        avg_over_value /= n.or_larger(1)
      endBlock

      avg_under_value = 0.0
      block n = 0
        forEach (color in bottom.pixels)
          if ((color.argb & 0xFF000000) >= 0x40)
            avg_under_value += color.argb & 0xFF
            ++n
          endIf
        endForEach
        avg_under_value /= n.or_larger(1)
      endBlock

      local v_scale_hsv = avg_under_value / avg_over_value.or_larger(1)

      if ((v_scale_gray >= 1.0) == (v_scale_hsv >= 1.0))
        local v_scale = (v_scale_gray + v_scale_hsv) / 2;

        native @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;

        loop (bitmap.width * bitmap.height)
          native
          @|RogueInt32 argb = *(++data);
           |RogueInt32 v = (RogueInt32)((argb & 0xFF) * $v_scale);
           |if (v > 255)    v = 255;
           |else if (v < 0) v = 0;
           |argb = (argb & 0xFFFFFF00) | v;
           |*data = argb;
        endLoop

        CmdChannelHSVToRGB.convert_hsv_to_rgb( bitmap )
        ImageList.selected.image.bitmap = bitmap
        ImageList.selected.image.is_modified = true
      endIf
endClass

class CmdFilterMatchColor( args:String[] ) : EditCmd
  METHODS
    method update_status
      use status = StatusBar
        status.print "filter matchcolor"
        if (not ImageList.selected)
          status.print " [no image selected]"
        elseIf (not ImageList.selected.next)
          status.print " [no underlying image to match]"
        endIf
      endUse

    method execute( ignore_repeat_count:Int )
      if (not ImageList.selected) return
      if (not ImageList.selected.next) return

      local bitmap = ImageList.selected.image.cloned_bitmap
      local bottom = ImageList.selected.next->(as ImageListItem).image.bitmap

      # Grayscale conversion factors
      local rw = (0.2990 * 65536)->Int
      local gw = (0.5870 * 65536)->Int
      local bw = (0.1140 * 65536)->Int

      # Color factor sums per brightness value
      local red    = Dim<<Int>>( 256 )
      local green  = Dim<<Int>>( 256 )
      local blue   = Dim<<Int>>( 256 )
      local count  = Dim<<Int>>( 256 )
      local avg_argb = Dim<<Int>>( 256 )

      forEach (color in bottom.pixels)
        if ((color.argb & 0xFF000000) >= 0x40)
          local r = (color.argb:>>>:16) & 0xff
          local g = (color.argb:>>>:8)  & 0xff
          local b =  color.argb         & 0xff
          local v = (r * rw) :>>: 16
          v += (g * gw) :>>: 16
          v += (b * bw) :>>: 16
          red[v]   += r
          green[v] += g
          blue[v]  += b
          ++count[v]
        endIf
      endForEach

      # Interpolate undefined brightness values
      if (count[0] == 0)
        count[0] = 1
      endIf

      if (count[255] == 0)
        local i = 254
        while (count[i] == 0 and i > 0) --i

        local n = count[i]
        local brightest_hsv = HSV( Color(red[i]/n, green[i]/n, blue[i]/n) )
        brightest_hsv.value = 1.0
        local extrapolated_brightest = brightest_hsv->Color
        red[255] = extrapolated_brightest.red_byte
        green[255] = extrapolated_brightest.green_byte
        blue[255] = extrapolated_brightest.blue_byte
        count[255] = 1
      endIf

      # Compute avg color per brightness value, interpolating any missing values
      local last_defined_i = 0
      local last_defined_color : Color
      forEach (n at i in count)
        if (n)
          local cur_color = Color( (red[i]/n)->Int, (green[i]/n)->Int, (blue[i]/n)->Int, 0 )
          avg_argb[i] = cur_color.argb

          forEach (missing_i in last_defined_i+1..<i)
            # Fill in missing avg_argb
            local p = (missing_i - last_defined_i)->Real / (i - last_defined_i)
            avg_argb[missing_i] = p.lerp( last_defined_color, cur_color ).argb
          endForEach

          last_defined_i = i
          last_defined_color = cur_color
        endIf
      endForEach

      # For each pixel in original image, compute brightness value and assign
      # average color from lookup table, preserving existing alpha.
      forEach (color in writer=bitmap.pixels.rewriter)
        local argb = color.argb
        local r = (argb:>>>:16) & 0xff
        local g = (argb:>>>:8)  & 0xff
        local b =  argb         & 0xff
        local v = (r * rw) :>>: 16
        v += (g * gw) :>>: 16
        v += (b * bw) :>>: 16
        writer.write( (argb & 0xFF000000) | avg_argb[v] )
      endForEach

endClass

class CmdFilterGray( args:String[] ) : EditCmd
  METHODS
    method update_status
      status = "filter gray".appending(args.join(" "))

    method execute( ignore_repeat_count:Int )
      if (not ImageList.selected) return

      local rw = 0.2990
      local gw = 0.5870
      local bw = 0.1140
      which (args.count)
        case 3
          rw = args[0]->Real
          gw = args[1]->Real
          bw = args[2]->Real
      endWhich

      local bitmap = ImageList.selected.image.cloned_bitmap
      convert_rgb_to_grayscale( bitmap, rw, gw, bw )

  GLOBAL METHODS
    method convert_rgb_to_grayscale( bitmap:Bitmap, rw=0.2990:Real, gw=0.5870:Real, bw=0.1140:Real )
      local sum = (rw + gw + bw).clamped_low(0.01)
      rw = (rw / sum)
      gw = (gw / sum)
      bw = (bw / sum)

      block rw=(rw*65536)->Int, gw=(gw*65536)->Int, bw=(bw*65536)->Int
        native @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;

        loop (bitmap.width * bitmap.height)
          local color = Color( native("*(++data)")->Int )
          local a = ((color.argb:>>>:24) & 0xff)
          local v = (((color.argb:>>>:16) & 0xff) * rw) :>>: 16
          v += (((color.argb:>>>:8) & 0xff) * gw) :>>: 16
          v += ((color.argb & 0xff) * bw) :>>: 16
          local argb = (a:<<:24) | (v:<<:16) | (v:<<:8) | v
          native @|*data = $argb;
        endLoop
      endBlock

endClass

class CmdFilterHardAlpha( args:String[] ) : EditCmd
  METHODS
    method update_status
      status = "filter hardalpha".appending(args.join(" "))

    method execute( ignore_repeat_count:Int )
      if (not ImageList.selected) return

      local bitmap = ImageList.selected.image.cloned_bitmap
      native @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;

      loop (bitmap.width * bitmap.height)
        local argb = native("*(++data)")->Int
        if (argb & 0xFF_000000) argb |= 0xFF_000000
        native @|*data = (RogueInt32)$argb;
      endLoop

endClass

class CmdGenerateMosaic( source_tile_count:XY, output_tile_count:XY ) : EditCmd
  METHODS
    method update_status
      use status = StatusBar
        status.print "generate mosaic "
        status.print "source-tile-count:$x$ "(source_tile_count.x->Int,source_tile_count.y->Int)
        status.print "output-tile-count:$x$ "(output_tile_count.x->Int,output_tile_count.y->Int)
        if (not ImageList.selected) status.print " [no image selected]"
      endUse

    method execute( ignore_repeat_count:Int )
      if (not ImageList.selected) return

      local tiles = ImageList.selected.image.bitmap.split( source_tile_count.x, source_tile_count.y )
      local size  = tiles.first.size
      local result = Bitmap( output_tile_count*size )

      forEach (j in 0..<size.y)
        forEach (i in 0..<size.x)
          tiles.random.blit( result, XY(i,j)*size )
        endForEach
      endForEach

      ImageList.add_and_select( Image(result) )
endClass

class CmdGenerateParts : EditCmd [singleton]
  METHODS
    method update_status
      status = "generate parts"

    method execute( ignore_repeat_count:Int )
      if (not ImageList.selected) return

      local source  = ImageList.selected.image.bitmap
      local w = source.size.x->Int
      local h = source.size.y->Int
      local w_max = w - 1
      local h_max = h - 1
      local source_pixels = source.pixels
      local pos = 0
      use flood_fill_queue=WorkList<<XYZ>>, checked=WorkList<<Logical>>
        checked.dim( w*h )

        forEach (i of source_pixels)
          if ((source_pixels[i].argb & 0xFF000000) == 0) checked[i] = true
        endForEach

        local add_index = ImageList.selected.index

        forEach (j in 0..<h)
          forEach (i in 0..<w)
            if (not checked[pos])
              checked[pos] = true
              flood_fill_queue.add( XYZ(i,j,pos) )

              local qi = 0
              local min_x = i
              local max_x = i
              local min_y = j
              local max_y = j
              while (qi < flood_fill_queue.count)
                local coord = flood_fill_queue[qi]
                if (coord.x < min_x) min_x = coord.x
                if (coord.x > max_x) max_x = coord.x
                if (coord.y < min_y) min_y = coord.y
                if (coord.y > max_y) max_y = coord.y
                if (coord.x > 0 and not checked[coord.z-1])
                  checked[coord.z-1] = true
                  flood_fill_queue.add( XYZ(coord.x-1,coord.y,coord.z-1) )
                endIf
                if (coord.x < w_max and not checked[coord.z+1])
                  checked[coord.z+1] = true
                  flood_fill_queue.add( XYZ(coord.x+1,coord.y,coord.z+1) )
                endIf
                if (coord.y > 0 and not checked[coord.z-w])
                  checked[coord.z-w] = true
                  flood_fill_queue.add( XYZ(coord.x,coord.y-1,coord.z-w) )
                endIf
                if (coord.y < h_max and not checked[coord.z+w])
                  checked[coord.z+w] = true
                  flood_fill_queue.add( XYZ(coord.x,coord.y+1,coord.z+w) )
                endIf
                ++qi
              endWhile

              local part = Bitmap( (max_x-min_x)+1, (max_y-min_y)+1 )
              local part_pixels = part.pixels
              local part_w = part.width
              forEach (pos in flood_fill_queue)
                part_pixels[ (pos.y->Int-min_y)*part_w + (pos.x->Int-min_x) ] = source_pixels[pos.z]
              endForEach

              ++add_index
              ImageList.insert( Image(part,"Part"), add_index )

              flood_fill_queue.clear
            endIf
            ++pos
          endForEach
        endForEach

        if (add_index > ImageList.selected.index)
          ImageList.select( ImageList.selected.index + 1 )
        endIf

      endUse

endClass

class CmdGeneratePerlin( frequency=8.0:Real ) : EditCmd
  METHODS
    method update_status
      local message = "generate perlin frequency:$"(frequency)
      if (not ImageList.selected) message .= appending( "[no image selected]" )
      status = message

    method execute( ignore_repeat_count:Int )
      if (not ImageList.selected) return

      local bitmap = ImageList.selected.image.cloned_bitmap

      use noise = WorkList<<Real>>
        PerlinNoise.[randomize].generate( bitmap.width, bitmap.height, frequency, noise )

        native
        @|RogueReal*  noise = $noise->as_reals - 1;
         |RogueInt32* pixels  = $bitmap->pixels->as_int32s - 1;

        loop (bitmap.width * bitmap.height)
          native
          @|RogueInt32 v = (RogueInt32) (*(++noise) * 128 + 128);
           |*(++pixels) = 0xFF000000 | (v<<16) | (v<<8) | v;
        endLoop

      endUse

endClass

class CmdChannelHSVToRGB( args:String[] ) : EditCmd
  METHODS
    method update_status
      status = "channel rgbtohsv".appending(args.join(" "))

    method apply
      local bitmap = ImageList.selected.image.cloned_bitmap
      convert_hsv_to_rgb( bitmap )

    method execute( ignore_repeat_count:Int )
      if (not ImageList.selected) return
      apply

  GLOBAL METHODS
    method convert_hsv_to_rgb( bitmap:Bitmap )
      local n = bitmap.pixels.count
      native...
        @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;
         |
         |while (--$n >= 0)
         |{
         |  RogueInt32 argb = *(++data);
         |  int   a = argb & 0xFF000000;
         |  float hue = ((argb >> 16) & 255) / 255.0f;
         |  float saturation = ((argb >> 8) & 255) / 255.0f;
         |  float value = (argb & 255) / 255.0f;
         |
         |  if (saturation)
         |  {
         |    float r, g, b;
         |    hue *= 6;
         |    int i = (int)hue;
         |    float f = hue - i;
         |    float p = value * (1 - saturation);
         |    float q = value * (1 - saturation * f);
         |    float t = value * (1 - saturation * (1 - f));
         |    switch (i)
         |    {
         |      case 0:
         |          r = value;
         |          g = t;
         |          b = p;
         |          break;
         |      case 1:
         |          r = q;
         |          g = value;
         |          b = p;
         |          break;
         |      case 2:
         |          r = p;
         |          g = value;
         |          b = t;
         |          break;
         |      case 3:
         |          r = p;
         |          g = q;
         |          b = value;
         |          break;
         |      case 4:
         |          r = t;
         |          g = p;
         |          b = value;
         |          break;
         |      default:
         |          r = value;
         |          g = p;
         |          b = q;
         |          break;
         |    }
         |
         |    *data = a | ((int)(r*255+0.5))<<16 | ((int)(g*255+0.5))<<8 | ((int)(b*255+0.5));
         |  }
         |  else
         |  {
         |    int v = (int)(value * 255 + 0.5);
         |    *data = a | (v<<16) | (v<<8) | v;
         |  }
         |}

endClass

class CmdFilterNormalize( lo:Int, hi:Int ) : EditCmd
  METHODS
    method update_status
      use status = StatusBar
        status.print "filter normalize $ $"(lo,hi)
        if (not ImageList.selected)
          status.print " [no image selected]"
        endIf
      endUse

    method execute
      if (not ImageList.selected) return

      local (original_lo,original_hi) = CmdInfoRange.range
      local original_range = (original_hi - original_lo) + 1
      local new_range = ((hi.clamped(0,255) - lo.clamped(0,255)) + 1).clamped_low(1)

      CmdChannelRGBToHSV(null).apply

      local bitmap = ImageList.selected.image.cloned_bitmap
      local n = bitmap.size.product
      native @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;
              |
              |while (--$n >= 0)
              |{
              |  RogueInt32 ahsv = *(++data);
              |  int v = ahsv & 255;
              |  *data = (ahsv & 0xFFFFFF00) | (((((v - $original_lo) * $new_range) / $original_range) + $lo) & 255);
              |}

      CmdChannelHSVToRGB(null).apply
endClass

class CmdFilterSeamless : EditCmd
  PROPERTIES
    blend : Real
    h, v  : Logical

  METHODS
    method init( blend=1.0, h=false, v=false )
      if (not h and not v) h = true; v = true

    method update_status
      use status = StatusBar
        status.print "filter seamless "
        if (h) status.print "h "
        if (v) status.print "v "
        if (blend > 1.0) status.print "blend $ pixels"(blend->Int - 1)
        else             status.print "blend $%"(blend.format(".0%"))
        if (not ImageList.selected)
          status.print " [no image selected]"
        endIf
      endUse

    method execute
      if (not ImageList.selected) return

      local selected = ImageList.selected
      local bitmap = selected.image.cloned_bitmap

      local OPAQUE      = Color( 0xFFFFFFFF )
      local TRANSPARENT = Color( 0x00FFFFFF )

      if (h)
        local blend_pixels : Int
        if (blend > 1.0) blend_pixels = blend - 1
        else             blend_pixels = bitmap.width * blend

        local halves = bitmap.split( 2, 1 )
        halves.swap( 0, 1 )
        local w1 = halves.first.width
        local h1 = halves.first.height
        local blend_w1 = (blend_pixels/2).or_smaller( w1 )
        halves.first.fill(
          Box( blend_w1, h1 ),
          Graphics::ColorGradient( OPAQUE, TRANSPARENT, OPAQUE, TRANSPARENT ),
          &fn=ColorGradientMultiplyBitmapFillFn,
          &channel_mask=0xFF000000
        )
        halves.first.fill(
          Box( blend_w1, 0, w1-blend_w1, h1 ),
          TRANSPARENT,
          &channel_mask=0xFF000000
        )

        local w2 = halves.last.width
        local h2 = halves.last.height
        local blend_w2 = (blend_pixels/2).or_smaller( w2 )
        halves.last.fill(
          Box( w2 - blend_w2, 0, blend_w2, h2 ),
          Graphics::ColorGradient( TRANSPARENT, OPAQUE, TRANSPARENT, OPAQUE ),
          &fn=ColorGradientMultiplyBitmapFillFn,
          &channel_mask=0xFF000000
        )
        halves.last.fill(
          Box( 0, 0, w2-blend_w2, h2 ),
          TRANSPARENT,
          &channel_mask=0xFF000000
        )

        (halves.first + halves.last).blit( bitmap, 0, 0, BitmapBlitFn.ALPHA )
      endIf

      if (v)
        local blend_pixels : Int
        if (blend > 1.0) blend_pixels = blend - 1
        else             blend_pixels = bitmap.height * blend

        local halves = bitmap.split( 1, 2 )
        halves.swap( 0, 1 )

        local w1 = halves.first.width
        local h1 = halves.first.height
        local blend_h1 = (blend_pixels/2).or_smaller( h1 )
        halves.first.fill(
          Box( w1, blend_h1 ),
          Graphics::ColorGradient( OPAQUE, OPAQUE, TRANSPARENT, TRANSPARENT ),
          &fn=ColorGradientMultiplyBitmapFillFn,
          &channel_mask=0xFF000000
        )
        halves.first.fill(
          Box( 0, blend_h1, w1, h1-blend_h1 ),
          TRANSPARENT,
          &channel_mask=0xFF000000
        )

        local w2 = halves.last.width
        local h2 = halves.last.height
        local blend_h2 = (blend_pixels/2).or_smaller( h2 )
        halves.last.fill(
          Box( 0, h2 - blend_h2, w2, blend_h2 ),
          Graphics::ColorGradient( TRANSPARENT, TRANSPARENT, OPAQUE, OPAQUE ),
          &fn=ColorGradientMultiplyBitmapFillFn,
          &channel_mask=0xFF000000
        )
        halves.last.fill(
          Box( 0, 0, w2, h2 - blend_h2 ),
          TRANSPARENT,
          &channel_mask=0xFF000000
        )

        (halves.first / halves.last).blit( bitmap, 0, 0, BitmapBlitFn.ALPHA )
      endIf

endClass

class CmdChannelRGBToHSV( args:String[] ) : EditCmd
  METHODS
    method update_status
      status = "channel rgbtohsv".appending(args.join(" "))

    method apply
      local bitmap = ImageList.selected.image.cloned_bitmap
      convert_rgb_to_hsv( bitmap )

    method execute( ignore_repeat_count:Int )
      if (not ImageList.selected) return
      apply

  GLOBAL METHODS
    method convert_rgb_to_hsv( bitmap:Bitmap )
      local n = bitmap.pixels.count
      native...
        @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;
         |
         |while (--$n >= 0)
         |{
         |  RogueInt32 argb = *(++data);
         |  int   a = argb & 0xFF000000;
         |  float r = ((argb >> 16) & 255) / 255.0f;
         |  float g = ((argb >> 8) & 255) / 255.0f;
         |  float b = (argb & 255) / 255.0f;
         |
         |  float maxrgb = (r >= g && r >= b) ? r : ((g >= b) ? g : b);
         |  float minrgb = (r <= g && r <= b) ? r : ((g <= b) ? g : b);
         |  float delta  = maxrgb - minrgb;
         |
         |  float value = maxrgb;
         |  float hue = 0.0f;
         |  float saturation = 0.0f;
         |
         |  if (maxrgb) saturation = delta / maxrgb;
         |
         |  if (delta)
         |  {
         |    if (r == maxrgb)      hue = (g - b) / delta;
         |    else if (g == maxrgb) hue = 2 + ((b - r) / delta);
         |    else                  hue = 4 + ((r - g) / delta);
         |
         |    hue /= 6.0;
         |    while (hue < 0)    hue += 1.0;
         |    while (hue >= 1.0) hue -= 1.0;
         |  }
         |
         |  *data = a | (((int)(hue*255))<<16) | (((int)(saturation*255))<<8) | ((int)(value*255));
         |}


endClass

class CmdChannelSwap( a:Int, b:Int ) : EditCmd
  METHODS
    method update_status
      status = "channel swap channels $<>$"("bgra"[a],"bgra"[b])

    method execute
      if ((a or b) and ImageView.image)
        local bitmap = ImageView.image.cloned_bitmap

        local a_shift = a * 8
        local b_shift = b * 8
        forEach (color at i in rewriter=bitmap.pixels.rewriter)
          local a = (color.argb :>>>: a_shift) & 0xFF
          local b = (color.argb :>>>: b_shift) & 0xFF
          local argb = color.argb & !(0xFF:<<:a_shift) & !(0xFF:<<:b_shift)
          argb |= (a :<<: b_shift) | (b :<<: a_shift)
          rewriter.write( Color(argb) )
        endForEach

        ImageView.mark_modified
      endIf
endClass

class CmdInfoRange : EditCmd [singleton]
  METHODS
    method update_status
      status = "info range"

    method execute( ignore_repeat_count:Int )
      if (not ImageList.selected) return

      local r = range
      status = "info range low:$ high:$"(r.low,r.high)

    method range->(low:Int,high:Int)
      local first = true
      local min_value = 0L
      local max_value = 0L

      local bitmap = ImageList.selected.image.bitmap
      local n = bitmap.pixels.count
      native...
        @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;
         |
         |while (--$n >= 0)
         |{
         |  RogueInt32 argb = *(++data);
         |  int r = (argb >> 16) & 255;
         |  int g = (argb >> 8) & 255;
         |  int b = argb & 255;
         |
         |  int rgb_max = (r >= g && r >= b) ? r : ((g >= b) ? g : b);
         |
         |  if ($first)
         |  {
         |    $first = 0;
         |    $min_value = rgb_max;
         |    $max_value = rgb_max;
         |  }
         |  else
         |  {
         |    $min_value = (rgb_max <= $min_value) ? rgb_max : $min_value;
         |    $max_value = (rgb_max >= $max_value) ? rgb_max : $max_value;
         |  }
         |}
      return (low:min_value,high:max_value)
endClass

class CmdLiteralBitwiseAND( argb:Int )  : EditCmd
  METHODS
    method update_status
      status = "& $ (bitwise AND)"(argb->Int32->String(&hex))

    method execute
      if local selected = ImageList.selected
        local bitmap = selected.image.cloned_bitmap
        local n = bitmap.pixels.count
        localize argb
        native @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;
                |
                |while (--$n >= 0)
                |{
                |  RogueInt32 argb = *(++data);
                |  *data = (argb & $argb);
                |}
      endIf
endClass

class CmdLiteralBitwiseOR( argb:Int )  : EditCmd
  METHODS
    method update_status
      status = "| $ (bitwise OR)"(argb->Int32->String(&hex))

    method execute
      if local selected = ImageList.selected
        local bitmap = selected.image.cloned_bitmap
        local n = bitmap.pixels.count
        localize argb
        native @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;
                |
                |while (--$n >= 0)
                |{
                |  RogueInt32 argb = *(++data);
                |  *data = (argb | $argb);
                |}
      endIf
endClass

class CmdLiteralBitwiseROL( bit_count:Int, include_alpha:Logical )  : EditCmd
  METHODS
    method update_status
      status = "< $ (bitwise ROL)"(bit_count)

    method execute
      if local selected = ImageList.selected
        local bitmap = selected.image.cloned_bitmap
        local n = bitmap.pixels.count
        localize bit_count
        if (include_alpha)
          bit_count &= 31
          local shr = 32 - bit_count
          local lsb_mask = which{ bit_count:(-1:>>:shr) || 0 }
          native @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;
                  |
                  |while (--$n >= 0)
                  |{
                  |  RogueInt32 argb = *(++data);
                  |  *data = (argb << $bit_count) | ((argb >> $shr) & $lsb_mask);
                  |}
        else
          bit_count %= 24
          local shr = 24 - bit_count
          local lsb_mask = which{ bit_count:(0xFFFFFF:>>:shr) || 0 }
          native @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;
                  |
                  |while (--$n >= 0)
                  |{
                  |  RogueInt32 argb = *(++data);
                  |  *data = (argb & 0xFF000000) | ((argb << $bit_count) & 0xFFFFFF) | ((argb >> $shr) & $lsb_mask);
                  |}
        endIf
      endIf
endClass

class CmdLiteralBitwiseROR( bit_count:Int, include_alpha:Logical )  : EditCmd
  METHODS
    method update_status
      status = "> $ (bitwise ROR)"(bit_count)

    method execute
      if local selected = ImageList.selected
        local bitmap = selected.image.cloned_bitmap
        local n = bitmap.pixels.count
        localize bit_count
        if (include_alpha)
          bit_count &= 31
          local shl = 32 - bit_count
          local lsb_mask = 0xFFFFFFFF:>>:bit_count
          native @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;
                  |
                  |while (--$n >= 0)
                  |{
                  |  RogueInt32 argb = *(++data);
                  |  *data = ((argb >> $bit_count) & $lsb_mask) | (argb << $shl);
                  |}
        else
          bit_count %= 24
          local shl = 24 - bit_count
          local lsb_mask = 0xffffff:>>>:bit_count
          native @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;
                  |
                  |while (--$n >= 0)
                  |{
                  |  RogueInt32 argb = *(++data);
                  |  *data = (argb & 0xFF000000) | ((argb >> $bit_count) & $lsb_mask) | ((argb << $shl) & 0xFFFFFF);
                  |}
        endIf
      endIf
endClass

class CmdLiteralBitwiseXOR( argb:Int )  : EditCmd
  METHODS
    method update_status
      status = "~ $ (bitwise XOR)"(argb->Int32->String(&hex))

    method execute
      if local selected = ImageList.selected
        local bitmap = selected.image.cloned_bitmap
        local n = bitmap.pixels.count
        localize argb
        native @|RogueInt32* data  = $bitmap->pixels->as_int32s - 1;
                |
                |while (--$n >= 0)
                |{
                |  RogueInt32 argb = *(++data);
                |  *data = (argb ^ $argb);
                |}
      endIf
endClass

class CmdLiteralAdd( argb:Int )  : EditCmd
  METHODS
    method update_status
      status = "+ $ (color add)"(argb->Int32->String(&hex))

    method execute
      if local selected = ImageList.selected
        local bitmap = selected.image.cloned_bitmap
        local n = bitmap.pixels.count
        localize argb
        native @|RogueInt32 literal_a = (($argb >> 24) & 255);
                |RogueInt32 literal_r = ((($argb >> 16) & 255) * literal_a) / 255;
                |RogueInt32 literal_g = ((($argb >>  8) & 255) * literal_a) / 255;
                |RogueInt32 literal_b = (( $argb        & 255) * literal_a) / 255;
                |
                |RogueInt32* data  = $bitmap->pixels->as_int32s - 1;
                |
                |while (--$n >= 0)
                |{
                |  RogueInt32 argb = *(++data);
                |  RogueInt32 a = argb & 0xFF000000;
                |  RogueInt32 r = (literal_r + ((argb >> 16) & 255));
                |  RogueInt32 g = (literal_g + ((argb >>  8) & 255));
                |  RogueInt32 b = (literal_b + ( argb        & 255));
                |  if (r > 255) r = 255;
                |  if (g > 255) g = 255;
                |  if (b > 255) b = 255;
                |  *data = (a | (r<<16) | (g<<8) | b);
                |}
      endIf
endClass

class CmdLiteralMultiply( argb:Int )  : EditCmd
  METHODS
    method update_status
      status = "* $ (color multiply)"(argb->Int32->String(&hex))

    method execute
      if local selected = ImageList.selected
        local bitmap = selected.image.cloned_bitmap
        local n = bitmap.pixels.count
        localize argb
        native @|RogueInt32 literal_a = (($argb >> 24) & 255);
                |RogueInt32 literal_r = (($argb >> 16) & 255);
                |RogueInt32 literal_g = (($argb >>  8) & 255);
                |RogueInt32 literal_b = ( $argb        & 255);
                |
                |RogueInt32* data  = $bitmap->pixels->as_int32s - 1;
                |
                |while (--$n >= 0)
                |{
                |  RogueInt32 argb = *(++data);
                |  RogueInt32 a = ((literal_a * ((argb >> 24) & 255)) / 255) << 24;
                |  RogueInt32 r = ((literal_r * ((argb >> 16) & 255)) / 255) << 16;
                |  RogueInt32 g = ((literal_g * ((argb >>  8) & 255)) / 255) << 8;
                |  RogueInt32 b = ((literal_b * ( argb        & 255)) / 255);
                |  *data = (a | r | g | b);
                |}
      endIf
endClass

class CmdMacro : Cmd [singleton]
  METHODS
    method allowed_in_macro->Logical
      return false

    method update_status

    method execute( ignore_repeat_count:Int )
      if (Vimage.recording_macro)
        Vimage.recording_macro = false
        status = "q (end macro) [can now (a)pply or apply to (A)ll]"
      else
        status = "q (begin recording macro) ['q' again to end]"
        Vimage.recording_macro = true
        Vimage.macro.clear
      endIf
endClass

class CmdMerge : EditCmd [singleton]
  METHODS
    method update_status
      use status = StatusBar
        status.print "e (merge images)"
        if (ImageList.selected)
          local available = ImageList.count - ImageList.selected.index
          local n = which{ Vimage.repeat_count || 2 }
          if (n > available) status.print " [not enough images]"
        else
          status.print " [no image selected]"
        endIf
      endUse

    method execute( n:Int )
      if (n == 1) n = 2

      local available : Int
      if (ImageList.selected)
        available = ImageList.count - ImageList.selected.index
      endIf
      if (n <= 1 or available < n) return

      local original_index = ImageList.selected.index

      use list = WorkList<<Image>>
        loop (n)
          local index = ImageList.selected.index
          list.add( ImageList.selected.image )
          ImageList.remove( ImageList.selected )
          if (index < ImageList.count)
            ImageList.select( index )
          elseIf (ImageList.count > 0)
            ImageList.select( ImageList.last_child->(as ImageListItem) )
            escapeLoop
          else
            ImageList.select( null )
            escapeLoop
          endIf
        endLoop

        local original = list.remove_last
        local result = original.cloned_bitmap
        forEach (image in list step -1)
          image.bitmap.blit( result, 0, 0, BitmapBlitFn.ALPHA )
        endForEach

        local result_image = Image( result, original.name )
        result_image.file = original.file
        ImageList.insert( result_image, original_index )
        ImageList.select( result_image )

      endUse

      ImageView.mark_modified
endClass

class CmdName( new_name:String ) : EditCmd
  METHODS
    method update_status
      noAction

    method execute
      if (ImageList.selected)
        ImageList.selected.request_redraw
        local image = ImageList.selected.image

        if local file = image.file
          local ext = file.extension
          if (not ext) ext = "png"
          if (String.exists(file.folder))
            new_name = "$/$.$"(file.folder,new_name,ext)
          else
            new_name = "$.$"(new_name,ext)
          endIf
          image.file = File(new_name)
        else
          if (not String.exists(File(new_name).extension)) new_name = File(new_name).with_extension("png").filepath
          image.file = File( new_name )
        endIf
        image.name = image.file.value.filepath
        image.is_modified = true
        status = "renamed image to " + File(new_name).filename
      endIf
endClass

class CmdNew( size:Size, insert:Logical ) : EditCmd
  METHODS
    method update_status
      status = "$ image [$x$] ($)"(which{insert:"NEW"||"new"},size.x,size.y,Vimage.bg_color)

    method execute
      local before_index = 0L
      local file = File( "NewImage.png" )
      if (ImageList.selected)
        before_index = ImageList.selected.index + 1
        if local cur_file = ImageList.selected.image.file
          local ext = cur_file.extension
          if (not String.exists(ext)) ext = "png"
          file = File( cur_file.parent/"NewImage.$"(ext) )
        endIf
      endIf

      if (insert and before_index > 0) --before_index

      file = ImageList.make_filepath_unique( file )

      local bitmap = Bitmap( size->XY ).[ clear(Vimage.bg_color) ]
      local image  = Image( bitmap, file ).[ is_modified=true ]
      local item   = ImageListItem( image )
      ImageList.insert( item, before_index )
      ImageList.select( item )
      ImageList.request_layout
endClass

class CmdOpen( args:String[] ) : EditCmd
  METHODS
    method update_status
      status = "open images for editing"

    method execute
      local first_index = which{ ImageList.selected:ImageList.selected.index+1 || 0 }
      local index = first_index

      forEach (arg in args)
        arg = arg.trimmed.unescaped
        local listing = File(arg).listing

        if (not listing.count)
          if (ImageList.selected)
            if local selected_file = ImageList.selected.image.file
              listing = (selected_file.parent/arg).listing
            endIf
          endIf
        endIf

        forEach (filepath in listing)
          local file = File( filepath )
          contingent
            necessary (not file.is_folder)
            local ext = file.extension.to_lowercase
            which (ext)
              case "bmp", "heic", "jpg", "jpeg", "png", "tif", "tiff", "webp"
                noAction
              others
                escapeContingent
            endWhich

            if (ImageList.contains(file))
              ImageList.select( ImageList.find(file) )
              return
            endIf

            ImageList.insert( Image(file), index )
            if (not ImageList.selected) ImageList.select( index )
            ++index
          endContingent
        endForEach
      endForEach

      if (index != first_index) ImageList.select( first_index )
      else                      status = " [file not found]"

endClass

class CmdQuit( force=false:Logical ) : EditCmd
  METHODS
    method update_status
      if (force) status = "quit! (force-quit)"
      else       status = "quit"

    method execute
      if (ImageList.selected)
        if (not force and ImageList.selected.image.is_modified)
          status = "q (quit) [image is modified; ':w' or else ':q!' to force-quit]"
          return
        endIf

        if (ImageList.count > 1)
          if (ImageList.selected is ImageList.last_child)
            ImageList.remove( ImageList.selected )
            ImageList.select( ImageList.last_child->(as ImageListItem) )
          else
            local index = ImageList.selected.index
            ImageList.remove( ImageList.selected )
            ImageList.select( index )
          endIf
        else
          VimageUI.is_running = false
        endIf
      else
        VimageUI.is_running = false
      endIf
endClass

class CmdQuitAll( force=false:Logical ) : Cmd
  METHODS
    method update_status
      if (force) status = "qq! (force-quit all)"
      else       status = "qq (quit all)"

    method execute
      if (not force)
        contingent
          forEach (item in ImageList)
            necessary (not item->(as ImageListItem).image.is_modified)
          endForEach
        unsatisfied
          status = "qq (quit all) [modified images exist; ':w' each or else ':qq!' to force-quit]"
          return
        endContingent
      endIf
      VimageUI.is_running = false
endClass

class CmdRemove : EditCmd [singleton]
  METHODS
    method update_status
      if (ImageList.selected and ImageList.selected.image.file)
        status = "rm '$' image file from folder"(ImageList.selected.image.file)
      elseIf (ImageList.selected)
        status = "rm [no file associated with current image]"
      else
        status = "rm [no current image]"
      endIf

    method execute
      if (ImageList.selected and ImageList.selected.image.file)
        local file = ImageList.selected.image.file.value
        file.delete
        ImageList.remove_selected
      endIf
endClass

class CmdResetZoom : Cmd [singleton]
  METHODS
    method update_status
      status = "0 (reset zoom)"

    method execute
      ImageView.reset_zoom
      if (State.current instanceOf ZoomState)
        state = ImageListState
      endIf
endClass

class CmdMaxZoom : Cmd [singleton]
  METHODS
    method update_status
      status = "SHIFT+0 (maximum zoom)"

    method execute
      if (ImageView.image)
        ImageView.maximum_zoom
        if (State.current not instanceOf ZoomState) state = ZoomState
      endIf
endClass

class CmdResizeToSize( size:Size ) : EditCmd
  METHODS
    method update_status
      use status = StatusBar
        status.print "resize "
        if (size.x and size.y)
          status.print "$x$"(size.x,size.y)
        elseIf (size.x)
          status.print "width $"(size.x)
        elseIf (size.y)
          status.print "height $"(size.y)
        endIf
        if (not ImageList.selected) status.print " [no image selected]"
      endUse

    method execute
      if (not ImageList.selected) return
      execute( ImageList.selected.image )

    method execute( image:Image )
      if (size.x)
        local width = size->XY.x
        if (size.y)
          local height = size->XY.y
          if (image.bitmap.size == XY(width,height)) return

          local bitmap = image.cloned_bitmap
          bitmap.resize( width, height )
        else
          local new_size = XY( width, image.bitmap.size.y*(width->Real/image.bitmap.size.x) )
          if (image.bitmap.size == new_size) return

          local bitmap = image.cloned_bitmap
          bitmap.resize( new_size.x, new_size.y )
        endIf
      elseIf (size.y)
        local height = size->XY.y
        local new_size = XY( image.bitmap.size.x*(height->Real/image.bitmap.size.y), height )
        if (image.bitmap.size == new_size) return

        local bitmap = image.cloned_bitmap
        bitmap.resize( new_size.x, new_size.y )
      endIf

      ImageView.show( image )
endClass

class CmdResizeToScale( sx:Real?, sy:Real? ) : EditCmd
  METHODS
    method update_status
      use status = StatusBar
        status.print "resize to scale "
        if (sx and sy)
          status.print "$x$"(sx,sy)
        elseIf (sx)
          status.print "sx $"(sx)
        elseIf (sy)
          status.print "sy $"(sy)
        endIf
        if (not ImageList.selected) status.print " [no image selected]"
      endUse

    method execute
      if (not ImageList.selected) return
      execute( ImageList.selected.image )

    method execute( image:Image )
      local w, h : Int?
      if (sx) w = (image.bitmap.width  * sx.value)->Int
      if (sy) h = (image.bitmap.height * sy.value)->Int
      CmdResizeToSize( Size(w,h) ).execute
endClass

class CmdRotateCW : EditCmd [singleton]
  METHODS
    method update_status
      if (ImageList.selected)
        status = "r (rotate 90 clockwise)"
      else
        status = "r (rotate 90 clockwise) [no image selected]"
      endIf

    method execute
      if (ImageList.selected)
        local img = ImageList.selected.image
        img.cloned_bitmap.rotate_90( &cw )
        img.zoom = 0
        ImageView.mark_modified
        ImageView.min_zoom = 0
      endIf
endClass

class CmdRotateCCW : EditCmd [singleton]
  METHODS
    method update_status
      if (ImageList.selected)
        status = "r (rotate 90 counter-clockwise)"
      else
        status = "r (rotate 90 counter-clockwise) [no image selected]"
      endIf

    method execute
      if (ImageList.selected)
        local img = ImageList.selected.image
        img.cloned_bitmap.rotate_90( &ccw )
        img.zoom = 0
        ImageView.mark_modified
        ImageView.min_zoom = 0
      endIf
endClass


class CmdPasteAfter : EditCmd [singleton]
  METHODS
    method init

    method update_status
      status = "p (paste after)"

    method execute( repeat_count:Int )
      local bitmap : Bitmap
      if (Vimage.using_os_clipboard)
        bitmap = Clipboard.bitmap
      else
        bitmap = Vimage.clipboard
      endIf

      if (bitmap)
        local file = File("NewImage.png")
        #if (Vimage.clipboard and bitmap.size == Vimage.clipboard.size and Vimage.clipboard_file)
        #  file = Vimage.clipboard_file.value
        #endIf
        file = ImageList.make_filepath_unique( file )

        loop repeat_count
          if (ImageList.selected)
            local before_index = ImageList.selected.index + 1
            ImageList.insert( Image(bitmap,file).[is_modified=true], before_index )
            ImageList.select( before_index )
          else
            ImageList.add( Image(bitmap,file).[is_modified=true] )
            ImageList.select( ImageList.count-1 )
          endIf
        endLoop
      else
        status = "p (paste after) [no image on clipboard]"
      endIf
endClass

class CmdPasteBefore : EditCmd [singleton]
  METHODS
    method init

    method update_status
      status = "P (paste before)"

    method execute( repeat_count:Int )
      local bitmap : Bitmap
      if (Vimage.using_os_clipboard)
        bitmap = Clipboard.bitmap
      else
        bitmap = Vimage.clipboard
      endIf

      if (bitmap)
        local file = File("NewImage.png")
        #if (Vimage.clipboard and bitmap.size == Vimage.clipboard.size and Vimage.clipboard_file)
        #  file = Vimage.clipboard_file.value
        #endIf
        file = ImageList.make_filepath_unique( file )

        loop repeat_count
          if (ImageList.selected)
            local before_index = ImageList.selected.index
            ImageList.insert( Image(bitmap,file), before_index )
            ImageList.select( before_index )
          else
            ImageList.add( Image(bitmap,file) )
            ImageList.select( 0 )
          endIf
        endLoop
      else
        status = "P (paste before) [no image on clipboard]"
      endIf
endClass

class CmdRedo : Cmd [singleton]
  METHODS
    method update_status
      if (Vimage.redo_stack.count)
        status = "^R (redo)"
      else
        status = "^R (redo) [no commands to redo]"
      endIf

    method execute
      Vimage.redo
endClass

class CmdRedoU : Cmd [singleton]
  METHODS
    method update_status
      if (Vimage.redo_stack.count)
        status = "U (redo)"
      else
        status = "U (redo) [no commands to redo]"
      endIf

    method execute
      Vimage.redo
endClass

class CmdRepeatLast : Cmd [singleton]
  PROPERTIES
    repeat_count : Int

  METHODS
    method allowed_in_macro->Logical
      return false

    method call
      local n = which{ Vimage.repeat_count || Vimage.last_repeat_count }
      prior.call
      Vimage.last_repeat_count = n

    method update_status
      if (not Vimage.last_cmd)
        status = ". [no editing commands to repeat]"
      endIf

    method execute
      if (Vimage.last_cmd)
        local n = which{ Vimage.repeat_count || Vimage.last_repeat_count }
        Vimage.repeat_count = n
        Vimage.execute( Vimage.last_cmd )
      endIf
endClass

class CmdSelectIndex( index:Int ) : Cmd [singleton]
  METHODS
    method update_status
      if (index >= 0 and index < ImageList.count)
        status = "select image $"(index)
      else
        status = "select image $ [index out of bounds]"(index)
      endIf

    method execute
      if (ImageList.count == 0) return

      local index = index.clamped( 0, ImageList.count-1 )
      ImageList.select( index )
endClass

class CmdSetBGColor( color:ColorValue ) : Cmd [singleton]
  METHODS
    method update_status
      if (color.is_random) status = "bg random"
      else                 status = "bg " + color

    method execute
      Vimage.bg_color = color
endClass

class CmdSetRepeatCount( n:Int? ) : Cmd
  METHODS
    method execute
      Vimage.repeat_count = n
endClass


class CmdScroll( dx:Real, dy:Real ) : Cmd
  METHODS
    method update_status
      if (dx > 0) status = "l (scroll right)"
      elseIf (dx < 0) status = "h (scroll left)"
      elseIf (dy > 0) status = "j (scroll down)"
      else            status = "k (scroll up)"

    method execute
      ImageView.scroll( XY(dx,dy) )
      if (State.current not instanceOf ZoomState)
        if (ImageView.image and ImageView.image.zoom != ImageView.default_zoom)
          state = ZoomState
        endIf
      endIf

endClass

class CmdShift( x:Int, y:Int, wrap:Logical ) : EditCmd
  METHODS
    method update_status
      if (ImageList.selected)
        status = "shift $ $$"(x,y,which{wrap:" wrap"||""})
      else
        status = "shift $ $$ [no image selected]"(x,y,which{wrap:" wrap"||""})
      endIf

    method execute
      if (ImageList.selected)
        if (wrap)
          local src = ImageList.selected.image.bitmap
          local dest = ImageList.selected.image.cloned_bitmap
          local w = src.width
          local h = src.height
          src.blit( dest, x, y )
          src.blit( dest, x-w, y )
          src.blit( dest, x, y-h )
          src.blit( dest, x-w, y-h )
        else
          ImageList.selected.image.cloned_bitmap.crop( -x, -y, x, y, Vimage.bg_color )
        endIf
        ImageView.mark_modified
      endIf
endClass

class CmdSplit( dims:XY ) : EditCmd
  PROPERTIES
    patch : Logical

  METHODS
    method init( patch )

    method update_status
      if (patch)
        if (ImageList.count == 0) status = "split patches [no image selected]"
        else                      status = "split patches"
      else
        local tiles_wide = dims.x->Int
        local tiles_high = dims.y->Int
        local total = tiles_wide * tiles_high

        use status = StatusBar
          status.print "split $x$ -> $ images"(tiles_wide,tiles_high,total)
          if (ImageList.count == 0)
            status.print " [no image selected]"
            return
          elseIf (tiles_wide < 1 or tiles_high < 1)
            status.print " [invalid split count]"
            return
          endIf
        endUse
      endIf

    method execute
      if (patch)
        .execute_split_patch
        return
      endIf

      local tiles_wide = dims.x->Int
      local tiles_high = dims.y->Int
      local total = tiles_wide * tiles_high

      local image  : Image
      local bitmap : Bitmap

      if (ImageList.count == 0)
        return
      elseIf (tiles_wide < 1 or tiles_high < 1)
        return
      else
        image = ImageList.selected.image
        bitmap = image.bitmap
      endIf

      local w = (bitmap.width / tiles_wide->Real).ceiling->Int
      local h = (bitmap.height / tiles_high->Real).ceiling->Int
      local bounds = Box( bitmap.size )

      local tiles = Bitmap[]
      forEach (j in 0..<tiles_high)
        forEach (i in 0..<tiles_wide)
          tiles.add( Bitmap(bitmap, (Box(i*w,j*h,w,h) & bounds).value) )
        endForEach
      endForEach
      .insert_images( tiles )

    method .execute_split_patch
      if (ImageList.count == 0) return
      local bitmap = ImageList.selected.image.bitmap

      if (bitmap.width < 1 or bitmap.height < 1) return
      local pixels = bitmap.pixels

      # Patch widths
      local w = 1
      local widths = [1]
      local cur = pixels[0]
      local bottom_i = (bitmap.height - 1) * bitmap.width
      local bottom_matches = (pixels[0] == pixels[bottom_i])
      forEach (i in 1..<bitmap.width)
        local next = pixels[i]
        if (next != cur)
          ++w
          cur = next
          widths.add( 1 )
        else
          ++widths.last
        endIf
        if (pixels[bottom_i+i] != next) bottom_matches = false
      endForEach

      if (bottom_matches)
        # Assume sizing guides on all four sides.
        --widths.first
        --widths.last

        # Patch heights
        local h = 1
        local heights = [1]
        local stride = bitmap.width
        cur = pixels[stride]
        local pos = stride * 2
        loop (bitmap.height - 3)
          local next = pixels[pos]
          pos += stride
          if (next != cur)
            ++h
            cur = next
            heights.add( 1 )
          else
            ++heights.last
          endIf
        endLoop

        local tiles = Bitmap[]
        local y = 1
        forEach (tile_h in heights)
          local x = 1
          forEach (tile_w in widths)
            tiles.add( Bitmap(bitmap, Box(x,y,tile_w,tile_h)) )
            x += tile_w
          endForEach
          y += tile_h
        endForEach
        .insert_images( tiles )

      else
        # Sizing guide on top only.
        local tile_h = bitmap.height - 1
        local tiles = Bitmap[]
        local x = 0
        forEach (tile_w in widths)
          tiles.add( Bitmap(bitmap, Box(x,1,tile_w,tile_h)) )
          x += tile_w
        endForEach
        .insert_images( tiles )
      endIf

    method .insert_images( tiles:Bitmap[] )
      local original = ImageList.selected.image
      local index = ImageList.selected.index

      local digits = 1L
      local limit = 10L
      while (limit < tiles.count)
        ++digits
        limit *= 10
      endWhile
      local fmt = "0$"(digits)

      forEach (tile at i in tiles step -1)
        local seq = i + 1
        local image : Image
        if (original.file)
          image = Image( tile, original.file.value.appending("-$"(seq.format(fmt))) ).[ is_modified=true ]
        elseIf (original.name)
          image = Image( tile, "$-$"(original.name,seq.format(fmt)) )
        else
          image = Image( tile, seq.format(fmt) )
        endIf
        ImageList.insert( image, index )
      endForEach

      ImageList.remove( ImageList.selected )
      ImageList.select( index )


endClass

class CmdToggleClipboard : Cmd [singleton]
  METHODS
    method update_status
      if (Vimage.using_os_clipboard)
        status = ''" (toggle clipboard) [now using internal clipboard]''
      else
        status = ''" (toggle clipboard) [now using OS clipboard]''
      endIf

    method execute
      Vimage.using_os_clipboard = not Vimage.using_os_clipboard
endClass

class CmdTrim( top=false:Logical, left=false:Logical, bottom=false:Logical, right=false:Logical ) : EditCmd [singleton]
  METHODS
    method update_status
      local st = String( "t " )
      local dirs = String[]
      if (top)    st.print( 't' ); dirs.add( "top" )
      if (left)   st.print( 'l' ); dirs.add( "left" )
      if (bottom) st.print( 'b' ); dirs.add( "bottom" )
      if (right)  st.print( 'r' ); dirs.add( "right" )
      st .= appending( "(trim transparent" )
      if (dirs.count) st .= appending( dirs.conjoin )
      st .= appending( "edge".pluralized(dirs.count) )
      st .= appending( ')' )
      status = st

    method execute
      if local item = ImageList.selected
        local img = ImageList.selected.image
        if (img.cloned_bitmap.trim(&=top,&=left,&=bottom,&=right))
          img.zoom = 0
          ImageView.mark_modified
          ImageView.min_zoom = 0
        endIf
      endIf
endClass

class CmdUndo : Cmd [singleton]
  METHODS
    method update_status
      if (Vimage.undo_stack.count)
        status = "u (undo)"
      else
        status = "u (undo) [no commands to undo]"
      endIf

    method execute
      Vimage.undo
endClass

class CmdWrite : EditCmd [singleton]
  METHODS
    method execute
      local filepath : String
      if (ImageList.selected.image.file)
        filepath = ImageList.selected.image.file.value.filepath
      else
        status = "w [missing filepath]"
        return
      endIf

      local file = File( filepath )
      local image = ImageList.selected.image
      image.name = file.filepath
      local bitmap = image.bitmap
      local ext = (File(filepath).extension.to_lowercase)
      which (ext)
        case "png"
          file.save( bitmap.to_png_bytes )
        case "jpg", "jpeg"
          file.save( bitmap.to_jpeg_bytes )
        others
          status = "[saving image type '$' is unsupported]"(ext)
          return
      endWhich
      status = ''"$" [$x$, $ bytes] written''(filepath,bitmap.width,bitmap.height,file.size.format(","))

      image.is_modified = false
      ImageList.selected.request_redraw
      TitleBar.request_redraw
endClass

class CmdSave : EditCmd [singleton]
  METHODS
    method execute
      local filepath : String
      if (ImageList.selected.image.file)
        filepath = ImageList.selected.image.file.value.filepath
      else
        status = "save [missing filepath]"
        return
      endIf

      CmdWrite.execute
endClass

class CmdWriteAll : Cmd [singleton]
  METHODS
    method execute( ignore_repeat_count:Int )
      VimageUI.actions += ActionWriteAll( this )
endClass

class CmdYank : Cmd [singleton]
  METHODS
    method update_status
      if (ImageList.selected)
        set_status( "y (copy image to clipboard)" )
      else
        set_status( "y [no image to copy]" )
      endIf

    method execute( ignore_repeat_count:Int )
      if (ImageList.selected)
        if (Vimage.using_os_clipboard)
          Clipboard.bitmap = ImageList.selected->(as ImageListItem).image.bitmap
        endIf
        Vimage.clipboard = ImageList.selected->(as ImageListItem).image.bitmap
        Vimage.clipboard_file = ImageList.selected->(as ImageListItem).image.file
      endIf
endClass

class CmdZoomIn : Cmd [singleton]
  METHODS
    method update_status
      status = "z (zoom in)"

    method execute
      ImageView.zoom_in
      if (ImageView.image)
        if (ImageView.image.zoom == ImageView.default_zoom)
          if (State.current is not ImageListState)
            State.change_state( ImageListState )
          endIf
        else
          if (State.current is not ZoomState)
            State.change_state( ZoomState )
          endIf
        endIf
      endIf
endClass

class CmdZoomOut : Cmd [singleton]
  METHODS
    method update_status
      status = "Z (zoom out)"

    method execute
      ImageView.zoom_out
      if (ImageView.image)
        if (ImageView.image.zoom == ImageView.default_zoom)
          if (State.current is not ImageListState)
            State.change_state( ImageListState )
          endIf
        else
          if (State.current is not ZoomState)
            State.change_state( ZoomState )
          endIf
        endIf
      endIf
endClass
