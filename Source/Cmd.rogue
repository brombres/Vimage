module Vimage
uses Math/Best

class Cmd
  GLOBAL METHODS
    method create( new_state:State )->Cmd
      return CmdChangeState( new_state )

    method create( callback:Function(e:KeyEvent) )->Cmd
      return CmdCallback( callback )

  METHODS
    method init

    method call
      update_status
      if (Vimage.repeat_count)
        local n = Vimage.repeat_count.value
        Vimage.repeat_count = null
        loop (n) execute
      else
        execute
      endIf

    method execute
      noAction

    method is_edit->Logical
      return false

    method is_interactive->Logical
      return false

    method on( e:KeyEvent )
      Vimage.execute( this )

    method repeatable( n:Int32 )->Cmd
      return null

    method set_state( new_state:State )
      State.current.change_state( new_state )

    method set_status( text:String, &dim )
      use status = StatusBar
        if (dim) status.style.dim
        status.print text
        if (dim) status.style.dim_off
      endUse

    method update_status
      noAction
endClass

class EditCmd : Cmd
  METHODS
    method is_edit->Logical
      return true
endClass

class InteractiveCmd : Cmd
  METHODS
    method is_interactive->Logical
      return true
endClass

class CmdCallback( callback:Function(e:KeyEvent) ) : Cmd
  METHODS
    method on( e:KeyEvent )
      callback( e )
endClass

class CmdChangeState( new_state:State ) : InteractiveCmd
  METHODS
    method on( e:KeyEvent )
      state = new_state
endClass

class CmdAspect( size:XY ) : EditCmd
  METHODS
    method update_status
      use status = StatusBar
        status.print "crop to have aspect ratio "
        status.print size.x
        status.print ':'
        status.print size.y
        if (not ImageList.selected) status.print " [no images]"
      endUse

    method execute
      if (not ImageList.selected) return
      execute( ImageList.selected.image )

    method execute( image:Image )
      local w = image.bitmap.width
      local h = image.bitmap.height
      local adjusted_height = (w->Real64 / size.x) * size.y : Int32
      local adjusted_width  = (h->Real64 / size.y) * size.x : Int32
      if (adjusted_width == w and adjusted_height == h) return

      local bitmap = image.cloned_bitmap
      if (adjusted_width < w) bitmap.crop( adjusted_width, h,  Vimage.anchor, Vimage.bg_color )
      else                    bitmap.crop( w, adjusted_height, Vimage.anchor, Vimage.bg_color )

      ImageView.show( image )
endClass

class CmdBeginCommandLine : InteractiveCmd [singleton]
  METHODS
    method update_status
      status = ":"

    method on( e:KeyEvent )
      Vimage.repeat_count = null
      VimageUI.command.clear
      update_status
      state = EnterCmdLineState()
endClass

class CmdCopy( a:String, b:String ) : EditCmd
  METHODS
    method update_status
      if (not ImageList.selected)
        status = "copy channels $ -> $ [no images]"(a,b)
        return
      endIf

      status = "copy channels $ -> $"(a,b)

    method execute
      if (not ImageList.selected)
        return
      endIf

      local bitmap = ImageList.selected.image.cloned_bitmap

      if (a.count == 1 and "bgra".contains(a))
        local a_shift = ("bgra".locate(a).value :<<: 3)
        forEach (dest_channel in b)
          local b_shift = ("bgra".locate(dest_channel).value :<<: 3)
          forEach (color in rewriter=bitmap.pixels.rewriter)
            local a = (color.argb :>>>: a_shift) & 0xFF
            local b = (color.argb :>>>: b_shift) & 0xFF
            local argb = color.argb & !(0xFF:<<:b_shift)
            argb |= (a :<<: b_shift)
            rewriter.write( Color(argb) )
          endForEach
        endForEach
      else
        # Replace color channel with constant value 00-ff
        local a = a->Int32(&base=16)
        forEach (dest_channel in b)
          local b_shift = ("bgra".locate(dest_channel).value :<<: 3)
          local write_a = a :<<: b_shift
          forEach (color in rewriter=bitmap.pixels.rewriter)
            local argb = color.argb & !(0xFF:<<:b_shift)
            argb |= write_a
            rewriter.write( Color(argb) )
          endForEach
        endForEach
      endIf

      ImageView.mark_modified
endClass

class CmdCrop( left:Int32, top:Int32, right:Int32, bottom:Int32 ) : EditCmd
  METHODS
    method update_status
      use status = StatusBar
        status.print( "crop $ $ $ $"(left,top,right,bottom) )
        if local selected = ImageList.selected
          local size = selected.image.bitmap.size
          if (size.x - (left+right) < 1 or size.y - (top+bottom) < 1)
            status.print " [exceeds image dimensions]"
          endIf
        else
          status.print " [no images]"
        endIf
      endUse

    method execute
      if (not ImageList.selected) return
      execute( ImageList.selected.image )

    method execute( image:Image )
      if (image.size.x - (left+right) < 1 or image.size.y - (top+bottom) < 1)
        return
      endIf

      image.cloned_bitmap.crop( left, top, right, bottom )
      ImageView.show( image )
endClass

class CmdCropToSize( width:Int32?, height:Int32? ) : EditCmd
  METHODS
    method update_status
      use status = StatusBar
        status.print "crop "
        if (width and height)
          status.print "$x$"(width,height)
        elseIf (width)
          status.print "width $"(width)
        elseIf (height)
          status.print "height $"(height)
        endIf
        if (not ImageList.selected) status.print " [no images]"
      endUse

    method execute
      if (not ImageList.selected) return
      execute( ImageList.selected.image )

    method execute( image:Image )
      if (width)
        local width = this.width.value
        if (width < 0) width = image.bitmap.width + width
        if (height)
          local height = this.height.value
          if (height < 0) height = image.bitmap.height + height
          if (image.bitmap.size == XY(width,height)) return

          local bitmap = image.cloned_bitmap
          bitmap.crop( width, height, Vimage.anchor, Vimage.bg_color )
        else
          local new_size = XY( width, image.bitmap.height )
          if (image.bitmap.size == new_size) return

          local bitmap = image.cloned_bitmap
          bitmap.crop( new_size.x, new_size.y, Vimage.anchor, Vimage.bg_color )
        endIf
      elseIf (height)
        local height = this.height.value
        if (height < 0) height = image.bitmap.height + height
        local new_size = XY( image.bitmap.width, height )
        if (image.bitmap.size == new_size) return

        local bitmap = image.cloned_bitmap
        bitmap.crop( new_size.x, new_size.y, Vimage.anchor, Vimage.bg_color )
      endIf

      ImageView.show( image )
endClass

class CmdDX : EditCmd [singleton]
  METHODS
    method on( e:KeyEvent )
endClass

class CmdDD : EditCmd [singleton]
  METHODS
    method update_status
      if (ImageList.selected)
        set_status( "dd (delete image and copy to clipboard)" )
      else
        set_status( "dd [no image to delete]" )
      endIf

    method execute
      if (ImageList.selected)
        Vimage.clipboard = ImageList.selected->(as ImageListItem).image
        local next = ImageList.selected.next
        ImageList.remove( ImageList.selected )
        if (next)
          ImageList.select( next->(as ImageListItem) )
        elseIf (ImageList.count)
          ImageList.select( ImageList.last_child->(as ImageListItem) )
        else
          ImageList.select( null )
        endIf
      endIf
endClass

class CmdImageListNext : Cmd [singleton]
  METHODS
    method update_status
      status = "j (down to next image)"

    method execute
      if local current = ImageList.selected
        if (current.next)
          ImageList.select( current.next->(as ImageListItem) )
        endIf
      endIf
endClass

class CmdImageListPrevious : Cmd [singleton]
  METHODS
    method update_status
      status = "k (up to previous image)"

    method execute
      if local current = ImageList.selected
        forEach (child in ImageList.children)
          if (child.next is current)
            ImageList.select( child->(as ImageListItem) )
            escapeForEach
          endIf
        endForEach
      endIf
endClass

class CmdImageListShiftDown : Cmd [singleton]
  METHODS
    method update_status
      status = "J (shift image down in list)"

    method execute
      if local current = ImageList.selected
        if local index = ImageList.locate( current )
          Vimage.save_undo
          ImageList.remove( current )
          ImageList.insert( current, index+1 )
          ImageList.request_layout
        endIf
      endIf
endClass

class CmdImageListShiftUp : Cmd [singleton]
  METHODS
    method update_status
      status = "K (shift image up in list)"

    method execute
      if local current = ImageList.selected
        if local index = ImageList.locate( current )
          if (index > 0)
            Vimage.save_undo
            ImageList.remove( current )
            ImageList.insert( current, index-1 )
            ImageList.request_layout
          endIf
        endIf
      endIf
endClass

class CmdParseJoinH : Cmd [singleton]
  METHODS
    method on( e:KeyEvent )
      local cmd = CmdJoin( XY( which{Vimage.repeat_count||2}, 1 ) )
      Vimage.repeat_count = null
      Vimage.execute( cmd )
endClass

class CmdParseJoinV : Cmd [singleton]
  METHODS
    method on( e:KeyEvent )
      local cmd = CmdJoin( XY( 1, which{Vimage.repeat_count||2} ) )
      Vimage.repeat_count = null
      Vimage.execute( cmd )
endClass

class CmdJoin( dims:XY ) : EditCmd
  METHODS
    method update_status
      local w = dims.x
      local h = dims.y
      local total = w * h
      local has_images = which{ ImageList.count:"" || " [no images]" }
      if (total <= 1)
        status = "s (join) $x$ [no effect]"(w,h)
        return
      elseIf (h == 1)
        if (w == 2) status = "s (join horizontal)$"(has_images)
        else        status = "$s (join horizontal)$"(w,has_images)
      elseIf (w == 1)
        if (h == 2) status = "S (join vertical)$"(has_images)
        else        status = "$S (join vertical)$"(h,has_images)
      elseIf (ImageList.count == 0)
        status = "join $x$ [no images]"(w,h)
        return
      else
        status = "join $x$"(w,h)
      endIf

    method execute
      local w = dims.x
      local h = dims.y
      local total = w * h

      if (ImageList.count == 0 or total <= 1) return

      local original_index = ImageList.selected.index

      use list = WorkList<<Image>>
        loop (total)
          local index = ImageList.selected.index
          list.add( ImageList.selected.image )
          ImageList.remove( ImageList.selected )
          if (index < ImageList.count)
            ImageList.select( index )
          elseIf (ImageList.count > 0)
            ImageList.select( ImageList.last_child->(as ImageListItem) )
            escapeLoop
          else
            ImageList.select( null )
            escapeLoop
          endIf
        endLoop

        while (list.count < total)
          list.add( Image(Bitmap(1,1).[clear(Vimage.bg_color)]) )
        endWhile

        # Find largest width and largest height
        local max_width = Best<<Int32>>( (a,b) => a > b )
        local max_height = Best<<Int32>>( (a,b) => a > b )
        forEach (item in list)
          max_width.consider( item.bitmap.width )
          max_height.consider( item.bitmap.height )
        endForEach

        local tile_w = max_width.value
        local tile_h = max_height.value

        local total_w, total_h : Int32
        if (w == 1)
          # Resize all images to be max width
          local cmd = CmdResize( tile_w, null )
          cmd.execute( (forEach in list) )
          total_w = tile_w
          total_h += (forEach in list).bitmap.height
        elseIf (h == 1)
          # Resize all images to be max height
          local cmd = CmdResize( null, tile_h )
          cmd.execute( (forEach in list) )
          total_w += (forEach in list).bitmap.width
          total_h = tile_h
        else
          # Reshape all images to be max width and/or height
          local cmd = CmdFit( tile_w, tile_h )
          cmd.execute( (forEach in list) )
          total_w = tile_w * w
          total_h = tile_h * h
        endIf

        local result = Bitmap( total_w, total_h )
        local cursor_y = 0
        forEach (j in 0..<h)
          local cursor_x = 0
          local dy = tile_h
          forEach (i in 0..<w)
            local bitmap = list[ j*w+i ].bitmap
            bitmap.blit( result, cursor_x, cursor_y )
            dy = bitmap.height
            cursor_x += bitmap.width
          endForEach
          cursor_y += dy
        endForEach

        local result_image = Image( result )
        ImageList.insert( result_image, original_index )
        ImageList.select( result_image )

      endUse
endClass

class CmdFill( width:Int32?, height:Int32? ) : EditCmd
  METHODS
    method update_status
      use status = StatusBar
        status.print "fill (resize to fill) "
        if (width and height)
          status.print "$x$"(width,height)
        elseIf (width)
          status.print "width $"(width)
        elseIf (height)
          status.print "height $"(height)
        endIf
        if (not ImageList.selected) status.print " [no images]"
      endUse

    method execute
      if (not ImageList.selected) return
      execute( ImageList.selected.image )

    method execute( image:Image )
      if (width)
        local width = this.width.value
        if (height)
          local height = this.height.value
          if (image.bitmap.size == XY(width,height)) return

          local bitmap = image.cloned_bitmap
          local x_scale = width->Real64 / image.bitmap.size.x
          local y_scale = height->Real64 / image.bitmap.size.y
          local scale = x_scale.or_larger( y_scale )
          bitmap.resize( bitmap.size * scale )
          bitmap.crop( width, height, Vimage.anchor, Vimage.bg_color )
        else
          local new_size = XY( width, image.bitmap.size.y*(width->Real64/image.bitmap.size.x) )
          if (image.bitmap.size == new_size) return

          local bitmap = image.cloned_bitmap
          bitmap.resize( new_size.x, new_size.y )
        endIf
      elseIf (height)
        local height = this.height.value
        local new_size = XY( image.bitmap.size.x*(height->Real64/image.bitmap.size.y), height )
        if (image.bitmap.size == new_size) return

        local bitmap = image.cloned_bitmap
        bitmap.resize( new_size.x, new_size.y )
      endIf

      ImageView.show( image )
endClass

class CmdFit( width:Int32?, height:Int32? ) : EditCmd
  METHODS
    method update_status
      use status = StatusBar
        status.print "fit (resize to fit) "
        if (width and height)
          status.print "$x$"(width,height)
        elseIf (width)
          status.print "width $"(width)
        elseIf (height)
          status.print "height $"(height)
        endIf
        if (not ImageList.selected) status.print " [no images]"
      endUse

    method execute
      if (not ImageList.selected) return
      execute( ImageList.selected.image )

    method execute( image:Image )
      if (width)
        local width = this.width.value
        if (height)
          local height = this.height.value
          if (image.bitmap.size == XY(width,height)) return

          local bitmap = image.cloned_bitmap
          local x_scale = width->Real64 / image.bitmap.size.x
          local y_scale = height->Real64 / image.bitmap.size.y
          local scale = x_scale.or_smaller( y_scale )
          bitmap.resize( bitmap.size * scale )
          bitmap.crop( width, height, Vimage.anchor, Vimage.bg_color )
        else
          local new_size = XY( width, image.bitmap.size.y*(width->Real64/image.bitmap.size.x) )
          if (image.bitmap.size == new_size) return

          local bitmap = image.cloned_bitmap
          bitmap.resize( new_size.x, new_size.y )
        endIf
      elseIf (height)
        local height = this.height.value
        local new_size = XY( image.bitmap.size.x*(height->Real64/image.bitmap.size.y), height )
        if (image.bitmap.size == new_size) return

        local bitmap = image.cloned_bitmap
        bitmap.resize( new_size.x, new_size.y )
      endIf

      ImageView.show( image )
endClass

class CmdFlipH : EditCmd [singleton]
  METHODS
    method update_status
      if (ImageList.selected)
        status = "f (flip horizontal)"
      else
        status = "f (flip horizontal) [no images]"
      endIf

    method execute
      if (ImageList.selected)
        local img = ImageList.selected.image
        img.cloned_bitmap.flip( &h )
        ImageView.mark_modified
      endIf
endClass

class CmdFlipV : EditCmd [singleton]
  METHODS
    method update_status
      if (ImageList.selected)
        status = "F (flip vertical)"
      else
        status = "F (flip vertical) [no images]"
      endIf

    method execute
      if (ImageList.selected)
        local img = ImageList.selected.image
        img.cloned_bitmap.flip( &v )
        ImageView.mark_modified
      endIf
endClass

class CmdNew( size:XY ) : EditCmd
  METHODS
    method update_status
      status = "new image [$x$] ($)"(size.x,size.y,Vimage.bg_color)

    method execute
      local before_index = 0
      if (ImageList.selected)
        if local index = ImageList.locate( ImageList.selected )
          before_index = index
        endIf
      endIf

      local bitmap = Bitmap( size ).[ clear(Vimage.bg_color) ]
      local image  = Image( bitmap )
      local item   = ImageListItem( image )
      ImageList.insert( item, before_index )
      ImageList.select( item )
      ImageList.request_layout
endClass

class CmdQuit( force=false:Logical ) : EditCmd
  METHODS
    method update_status
      if (force) status = "quit! (force-quit)"
      else       status = "quit"

    method execute
      if (ImageList.selected)
        if (not force and ImageList.selected.image.is_modified)
          status = "q (quit) [image is modified; ':w' or else ':q!' to force-quit]"
          return
        endIf

        if (ImageList.count > 1)
          if (ImageList.selected is ImageList.last_child)
            ImageList.remove( ImageList.selected )
            ImageList.select( ImageList.last_child->(as ImageListItem) )
          else
            local index = ImageList.selected.index
            ImageList.remove( ImageList.selected )
            ImageList.select( index )
          endIf
        else
          VimageUI.is_running = false
        endIf
      else
        VimageUI.is_running = false
      endIf
endClass

class CmdQuitAll( force=false:Logical ) : EditCmd
  METHODS
    method update_status
      if (force) status = "qa! (force-quit all)"
      else       status = "qa (quit all)"

    method execute
      if (not force)
        contingent
          forEach (item in ImageList)
            necessary (not item->(as ImageListItem).image.is_modified)
          endForEach
        unsatisfied
          status = "qa (quit all) [modified images exist; ':w' each or else ':qa!' to force-quit]"
          return
        endContingent
      endIf
      VimageUI.is_running = false
endClass

class CmdResize( width:Int32?, height:Int32? ) : EditCmd
  METHODS
    method update_status
      use status = StatusBar
        status.print "resize "
        if (width and height)
          status.print "$x$"(width,height)
        elseIf (width)
          status.print "width $"(width)
        elseIf (height)
          status.print "height $"(height)
        endIf
        if (not ImageList.selected) status.print " [no images]"
      endUse

    method execute
      if (not ImageList.selected) return
      execute( ImageList.selected.image )

    method execute( image:Image )
      if (width)
        local width = this.width.value
        if (height)
          local height = this.height.value
          if (image.bitmap.size == XY(width,height)) return

          local bitmap = image.cloned_bitmap
          bitmap.resize( width, height )
        else
          local new_size = XY( width, image.bitmap.size.y*(width->Real64/image.bitmap.size.x) )
          if (image.bitmap.size == new_size) return

          local bitmap = image.cloned_bitmap
          bitmap.resize( new_size.x, new_size.y )
        endIf
      elseIf (height)
        local height = this.height.value
        local new_size = XY( image.bitmap.size.x*(height->Real64/image.bitmap.size.y), height )
        if (image.bitmap.size == new_size) return

        local bitmap = image.cloned_bitmap
        bitmap.resize( new_size.x, new_size.y )
      endIf

      ImageView.show( image )
endClass

class CmdRotateCW : EditCmd [singleton]
  METHODS
    method update_status
      if (ImageList.selected)
        status = "r (rotate 90º clockwise)"
      else
        status = "r (rotate 90º clockwise) [no images]"
      endIf

    method execute
      if (ImageList.selected)
        local img = ImageList.selected.image
        img.cloned_bitmap.rotate_90( &cw )
        img.zoom = 0
        ImageView.mark_modified
        ImageView.min_zoom = 0
      endIf
endClass

class CmdRotateCCW : EditCmd [singleton]
  METHODS
    method update_status
      if (ImageList.selected)
        status = "r (rotate 90º counter-clockwise)"
      else
        status = "r (rotate 90º counter-clockwise) [no images]"
      endIf

    method execute
      if (ImageList.selected)
        local img = ImageList.selected.image
        img.cloned_bitmap.rotate_90( &ccw )
        img.zoom = 0
        ImageView.mark_modified
        ImageView.min_zoom = 0
      endIf
endClass

class CmdPaste( repeat_count:Int32 ) : EditCmd [singleton]
  METHODS
    method init

    method on( e:KeyEvent )
      Vimage.execute( CmdPaste(Vimage.reset_repeat_count) )

    method update_status
      status = "$p (paste)"(which{repeat_count==1:""||repeat_count+""})

    method execute
      local bitmap = Vimage.clipboard.bitmap
      loop repeat_count
        if (ImageList.selected)
          local before_index = ImageList.selected.index
          ImageList.insert( Image(bitmap), before_index )
          ImageList.select( before_index )
        else
          ImageList.add( Image(bitmap) )
          ImageList.select( 0 )
        endIf
      endLoop
endClass

class CmdRedo : Cmd [singleton]
  METHODS
    method update_status
      if (Vimage.redo_stack.count)
        status = "^R (redo)"
      else
        status = "^R (redo) [no commands to redo]"
      endIf

    method execute
      Vimage.redo
endClass

class CmdRepeatLast : Cmd [singleton]
  METHODS
    method update_status
      if (not Vimage.last_cmd)
        status = ". [no editing commands to repeat]"
      endIf

    method execute
      if (Vimage.last_cmd)
        Vimage.execute( Vimage.last_cmd )
      endIf
endClass

class CmdScroll( dx:Real, dy:Real ) : EditCmd
  METHODS
    method update_status
      if (dx > 0) status = "l (scroll right)"
      elseIf (dx < 0) status = "h (scroll left)"
      elseIf (dy > 0) status = "j (scroll down)"
      else            status = "k (scroll up)"

    method execute
      ImageView.scroll( RealXY(dx,dy) )
      if (State.current not instanceOf ZoomState)
        if (ImageView.image and ImageView.image.zoom != ImageView.default_zoom)
          state = ZoomState
        endIf
      endIf

endClass

class CmdSplit( dims:XY ) : EditCmd
  METHODS
    method update_status
      local tiles_wide = dims.x
      local tiles_high = dims.y
      local total = tiles_wide * tiles_high

      use status = StatusBar
        status.print "split $x$ -> $ images"(tiles_wide,tiles_high,total)
        if (ImageList.count == 0)
          status.print " [no images]"
          return
        elseIf (tiles_wide < 1 or tiles_high < 1)
          status.print " [invalid split count]"
          return
        else
          local image = ImageList.selected.image
          local bitmap = image.bitmap
          if (bitmap.width % tiles_wide)
            status.print " [image width must be an even multiple of $]"(tiles_wide)
            return
          endIf
          if (bitmap.height % tiles_high)
            status.print " [image height must be an even multiple of $]"(tiles_high)
            return
          endIf
        endIf
      endUse


    method execute
      local tiles_wide = dims.x
      local tiles_high = dims.y
      local total = tiles_wide * tiles_high

      local image  : Image
      local bitmap : Bitmap

      if (ImageList.count == 0)
        return
      elseIf (tiles_wide < 1 or tiles_high < 1)
        return
      else
        image = ImageList.selected.image
        bitmap = image.bitmap
        if (bitmap.width % tiles_wide)
          return
        endIf
        if (bitmap.height % tiles_high)
          return
        endIf
      endIf

      local index = ImageList.selected.index
      local digits = 1
      local limit = 10
      while (limit < total)
        ++digits
        limit *= 10
      endWhile
      local fmt = "0$"(digits)

      local w = bitmap.width / tiles_wide
      local h = bitmap.height / tiles_high

      forEach (j in tiles_high-1 downTo 0)
        forEach (i in tiles_wide-1 downTo 0)
          local seq = j*tiles_wide + i
          local tile = Bitmap( bitmap, Box(i*w,j*h,w,h) )
          local img : Image
          if (image.file)
            img = Image( tile, image.file.value.appending("-$"(seq.format(fmt))) ).[ is_modified=true ]
          elseIf (image.name)
            img = Image( tile, "$-$"(image.name,seq.format(fmt)) )
          else
            img = Image( tile, seq.format(fmt) )
          endIf
          ImageList.insert( img, index )
        endForEach
      endForEach

      ImageList.remove( ImageList.selected )
      ImageList.select( index )

endClass

class CmdParseStack : Cmd [singleton]
  METHODS
    method on( e:KeyEvent )
      local cmd = CmdStack( which{Vimage.repeat_count||2} )
      Vimage.repeat_count = null
      Vimage.execute( cmd )
endClass

class CmdStack( n:Int32 ) : EditCmd
  METHODS
    method update_status
      use status = StatusBar
        if (n != 2) status.print n
        status.print "t (stack images)"
        if (ImageList.selected)
          local available = ImageList.count - ImageList.selected.index
          if (n > available) status.print " [not enough images]"
        else
          status.print " [no images]"
        endIf
      endUse

    method execute
      local available : Int32
      if (ImageList.selected)
        available = ImageList.count - ImageList.selected.index
      endIf
      if (n <= 1 or available < n) return

      local bitmap = ImageList.selected.image.bitmap

      local original_index = ImageList.selected.index

      use list = WorkList<<Image>>
        loop (n)
          local index = ImageList.selected.index
          list.add( ImageList.selected.image )
          ImageList.remove( ImageList.selected )
          if (index < ImageList.count)
            ImageList.select( index )
          elseIf (ImageList.count > 0)
            ImageList.select( ImageList.last_child->(as ImageListItem) )
            escapeLoop
          else
            ImageList.select( null )
            escapeLoop
          endIf
        endLoop

        local largest_width  = Best<<Int32>>( (a,b) => a > b )
        local largest_height = Best<<Int32>>( (a,b) => a > b )
        largest_width.consider( (forEach in list).bitmap.width )
        largest_height.consider( (forEach in list).bitmap.height )
        (forEach in list).bitmap.crop( largest_width.value, largest_height.value, Vimage.anchor, Vimage.bg_color )

        local result = list.remove_last.cloned_bitmap
        forEach (image in list step -1)
          image.bitmap.blit( result, 0, 0, BitmapBlitFn.ALPHA )
        endForEach

        local result_image = Image( result )
        ImageList.insert( result_image, original_index )
        ImageList.select( result_image )

      endUse

      ImageView.mark_modified
endClass

class CmdSwap( a:Int32, b:Int32 ) : EditCmd
  METHODS
    method update_status
      status = "swap channels $<>$"("bgra"[a],"bgra"[b])

    method execute
      if ((a or b) and ImageView.image)
        local bitmap = ImageView.image.cloned_bitmap

        local a_shift = a * 8
        local b_shift = b * 8
        forEach (color at i in rewriter=bitmap.pixels.rewriter)
          local a = (color.argb :>>>: a_shift) & 0xFF
          local b = (color.argb :>>>: b_shift) & 0xFF
          local argb = color.argb & !(0xFF:<<:a_shift) & !(0xFF:<<:b_shift)
          argb |= (a :<<: b_shift) | (b :<<: a_shift)
          rewriter.write( Color(argb) )
        endForEach

        ImageView.mark_modified
      endIf
endClass

class CmdUndo : Cmd [singleton]
  METHODS
    method update_status
      if (Vimage.undo_stack.count)
        status = "u (undo)"
      else
        status = "u (undo) [no commands to undo]"
      endIf

    method execute
      Vimage.undo
endClass

class CmdWrite : EditCmd [singleton]
  METHODS
    method execute
      local filepath : String
      if (ImageList.selected.image.file)
        filepath = ImageList.selected.image.file.value.filepath
      else
        status = "w [missing filepath]"
        return
      endIf

      local file = File( filepath )
      local image = ImageList.selected.image
      image.file = file
      image.name = file.filepath
      local bitmap = image.bitmap
      which (File(filepath).extension.to_lowercase)
        case "png"
          file.save( bitmap.to_png_bytes )
        case "jpg", ".jpeg"
          file.save( bitmap.to_jpeg_bytes )
      endWhich
      status = ''"$" [$x$, $ bytes] written''(filepath,bitmap.width,bitmap.height,file.size.format(","))

      image.is_modified = false
endClass

class CmdYank : EditCmd [singleton]
  METHODS
    method update_status
      if (ImageList.selected)
        set_status( "yy (copy image to clipboard)" )
      else
        set_status( "yy [no image to copy]" )
      endIf

    method execute
      if (ImageList.selected)
        Vimage.clipboard = ImageList.selected->(as ImageListItem).image
      endIf
endClass

class CmdYankAndPaste : EditCmd [singleton]
  METHODS
    method update_status
      if (ImageList.selected)
        set_status( "yp (yank and paste; duplicate)" )
      else
        set_status( "yp (yank and paste) [no image to duplicate]" )
      endIf

    method execute
      if (ImageList.selected)
        Vimage.clipboard = ImageList.selected->(as ImageListItem).image

        local bitmap = Vimage.clipboard.bitmap.cloned
        local before_index = ImageList.selected.index
        ImageList.insert( Image(bitmap), before_index )
        ImageList.select( before_index )
      endIf
endClass

class CmdZoomIn : Cmd [singleton]
  METHODS
    method update_status
      status = "z (zoom in)"

    method execute
      ImageView.zoom_in
      if (ImageView.image)
        if (ImageView.image.zoom == ImageView.default_zoom)
          if (State.current is not ImageListState)
            State.change_state( ImageListState )
          endIf
        else
          if (State.current is not ZoomState)
            State.change_state( ZoomState )
          endIf
        endIf
      endIf
endClass

class CmdZoomOut : Cmd [singleton]
  METHODS
    method update_status
      status = "Z (zoom out)"

    method execute
      ImageView.zoom_out
      if (ImageView.image)
        if (ImageView.image.zoom == ImageView.default_zoom)
          if (State.current is not ImageListState)
            State.change_state( ImageListState )
          endIf
        else
          if (State.current is not ZoomState)
            State.change_state( ZoomState )
          endIf
        endIf
      endIf
endClass
