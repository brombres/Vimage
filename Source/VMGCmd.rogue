uses Math/Best

class VMGCmd
  METHODS
    method execute

    method set_status( text:String, &dim )
      use status = VMGStatusBar
        if (dim) status.style.dim
        status.print text
        if (dim) status.style.dim_off
      endUse

    method update_status
      noAction
endClass

class VMGCmdCopy( a:String, b:String ) : VMGCmd
  METHODS
    method update_status
      if (not VMGImageList.selected)
        status = "copy channels $ -> $ [no images]"(a,b)
        return
      endIf

      status = "copy channels $ -> $"(a,b)

    method execute
      if (not VMGImageList.selected)
        return
      endIf

      local bitmap = VMGImageList.selected.image.cloned_bitmap

      if (a.count == 1 and "bgra".contains(a))
        local a_shift = ("bgra".locate(a).value :<<: 3)
        forEach (dest_channel in b)
          local b_shift = ("bgra".locate(dest_channel).value :<<: 3)
          forEach (color in rewriter=bitmap.pixels.rewriter)
            local a = (color.argb :>>>: a_shift) & 0xFF
            local b = (color.argb :>>>: b_shift) & 0xFF
            local argb = color.argb & !(0xFF:<<:b_shift)
            argb |= (a :<<: b_shift)
            rewriter.write( Color(argb) )
          endForEach
        endForEach
      else
        # Replace color channel with constant value 00-ff
        local a = a->Int32(&base=16)
        forEach (dest_channel in b)
          local b_shift = ("bgra".locate(dest_channel).value :<<: 3)
          forEach (color in rewriter=bitmap.pixels.rewriter)
            local argb = color.argb & !(0xFF:<<:b_shift)
            argb |= a
            rewriter.write( Color(argb) )
          endForEach
        endForEach
      endIf

      VMGImageView.mark_modified
endClass

class VMGCmdDD : VMGCmd [singleton]
  METHODS
    method update_status
      if (VMGImageList.selected)
        set_status( "dd (delete image and copy to clipboard)" )
      else
        set_status( "dd [no image to delete]" )
      endIf

    method execute
      if (VMGImageList.selected)
        Vimage.clipboard = VMGImageList.selected->(as VMGImageListItem).image
        local next = VMGImageList.selected.next
        VMGImageList.remove( VMGImageList.selected )
        if (next)
          VMGImageList.select( next->(as VMGImageListItem) )
        elseIf (VMGImageList.count)
          VMGImageList.select( VMGImageList.last_child->(as VMGImageListItem) )
        else
          VMGImageList.select( null )
        endIf
      endIf
endClass

class VMGCmdNew( size:XY, bg_color:Color ) : VMGCmd
  METHODS
    method update_status
      status = "new image [$x$] ($)"(size.x,size.y,bg_color)

    method execute
      local before_index = 0
      if (VMGImageList.selected)
        if local index = VMGImageList.locate( VMGImageList.selected )
          before_index = index
        endIf
      endIf

      local bitmap = Bitmap( size ).[ clear(bg_color) ]
      local image  = VMGImage( bitmap )
      local item   = VMGImageListItem( image )
      VMGImageList.insert( item, before_index )
      VMGImageList.select( item )
      VMGImageList.request_layout
endClass

class VMGCmdJoin( dims:XY ) : VMGCmd
  METHODS
    method update_status
      local w = dims.x
      local h = dims.y
      local total = w * h
      local has_images = which{ VMGImageList.count:"" || " [no images]" }
      if (total <= 1)
        status = "s (join) $x$ [no effect]"(w,h)
        return
      elseIf (h == 1)
        if (w == 2) status = "s (join horizontal)$"(has_images)
        else        status = "$s (join horizontal)$"(w,has_images)
      elseIf (w == 1)
        if (h == 2) status = "S (join vertical)$"(has_images)
        else        status = "$S (join vertical)$"(h,has_images)
      elseIf (VMGImageList.count == 0)
        status = "join $x$ [no images]"(w,h)
        return
      else
        status = "join $x$"(w,h)
      endIf

    method execute
      local w = dims.x
      local h = dims.y
      local total = w * h

      if (VMGImageList.count == 0) return

      use list = WorkList<<VMGImage>>
        loop (total)
          local index = VMGImageList.selected.index
          list.add( VMGImageList.selected.image )
          VMGImageList.remove( VMGImageList.selected )
          if (index < VMGImageList.count)
            VMGImageList.select( index )
          elseIf (VMGImageList.count > 0)
            VMGImageList.select( VMGImageList.last_child->(as VMGImageListItem) )
            escapeLoop
          else
            VMGImageList.select( null )
            escapeLoop
          endIf
        endLoop

        while (list.count < total)
          list.add( VMGImage(Bitmap(1,1).[clear(Vimage.bg_color)]) )
        endWhile

        # Scale up elements of each row to be same height.
        forEach (j in 0..<h)
          local max_height = Best<<Int32>>( (a,b) => a > b )
          forEach (i in 0..<w)
            max_height.consider( list[j*w+i].bitmap.height )
          endForEach

          block max_height = max_height.value
            forEach (i in 0..<w)
              local bitmap = list[j*w+i].bitmap
              local new_size = XY( bitmap.width*(max_height->Real64/bitmap.height), max_height )
              if (new_size != bitmap.size)
                list[j*w+i].cloned_bitmap.resize( new_size )
              endIf
            endForEach
          endBlock
        endForEach

        # Scale up elements of each column to be same width.
        forEach (i in 0..<w)
          local max_width = Best<<Int32>>( (a,b) => a > b )
          forEach (j in 0..<h)
            max_width.consider( list[j*w+i].bitmap.width )
          endForEach

          block max_width = max_width.value
            forEach (j in 0..<h)
              local bitmap = list[j*w+i].bitmap
              local new_size = XY( max_width, bitmap.height*(max_width->Real64/bitmap.width) )
              list[j*w+i].cloned_bitmap.resize( new_size )
            endForEach
          endBlock
        endForEach

        local total_w = 0
        total_w += list[ (forEach in 0..<w) ].bitmap.width
        local total_h = 0
        total_h += list[ (forEach in 0..<h)*w ].bitmap.height

        local result = Bitmap( total_w, total_h )
        local cursor_y = 0
        forEach (j in 0..<h)
          local cursor_x = 0
          local dy : Int32
          forEach (i in 0..<w)
            local bitmap = list[ j*w+i ].bitmap
            bitmap.blit( result, cursor_x, cursor_y )
            cursor_x += bitmap.width
            dy = bitmap.height
          endForEach
          cursor_y += dy
        endForEach

        local result_image = VMGImage( result )
        local before_index = which{ VMGImageList.selected:VMGImageList.selected.index || 0 }
        VMGImageList.insert( result_image, before_index )
        VMGImageList.select( result_image )

      endUse

endClass

class VMGCmdPaste( repeat_count:Int32 ) : VMGCmd
  METHODS
    method update_status
      status = "$p (paste)"(which{repeat_count==1:""||repeat_count+""})

    method execute
      local bitmap = Vimage.clipboard.bitmap.cloned
      if (VMGImageList.selected)
        local before_index = VMGImageList.selected.index
        VMGImageList.insert( VMGImage(bitmap), before_index )
        VMGImageList.select( before_index )
      else
        VMGImageList.add( VMGImage(bitmap) )
        VMGImageList.select( 0 )
      endIf
endClass

class VMGCmdSplit( dims:XY ) : VMGCmd
  METHODS
    method update_status
      local tiles_wide = dims.x
      local tiles_high = dims.y
      local total = tiles_wide * tiles_high

      use status = VMGStatusBar
        status.print "split $x$ -> $ images"(tiles_wide,tiles_high,total)
        if (VMGImageList.count == 0)
          status.print " [no images]"
          return
        elseIf (tiles_wide < 1 or tiles_high < 1)
          status.print " [invalid split count]"
          return
        else
          local image = VMGImageList.selected.image
          local bitmap = image.bitmap
          if (bitmap.width % tiles_wide)
            status.print " [image width must be an even multiple of $]"(tiles_wide)
            return
          endIf
          if (bitmap.height % tiles_high)
            status.print " [image height must be an even multiple of $]"(tiles_high)
            return
          endIf
        endIf
      endUse


    method execute
      local tiles_wide = dims.x
      local tiles_high = dims.y
      local total = tiles_wide * tiles_high

      local image  : VMGImage
      local bitmap : Bitmap

      if (VMGImageList.count == 0)
        return
      elseIf (tiles_wide < 1 or tiles_high < 1)
        return
      else
        image = VMGImageList.selected.image
        bitmap = image.bitmap
        if (bitmap.width % tiles_wide)
          return
        endIf
        if (bitmap.height % tiles_high)
          return
        endIf
      endIf

      local index = VMGImageList.selected.index
      local digits = 1
      local limit = 10
      while (limit < total)
        ++digits
        limit *= 10
      endWhile
      local fmt = "0$"(digits)

      local w = bitmap.width / tiles_wide
      local h = bitmap.height / tiles_high

      forEach (j in tiles_high-1 downTo 0)
        forEach (i in tiles_wide-1 downTo 0)
          local seq = j*tiles_wide + i
          local tile = Bitmap( bitmap, Box(i*w,j*h,w,h) )
          local img : VMGImage
          if (image.file)
            img = VMGImage( tile, image.file.value.appending("-$"(seq.format(fmt))) )
          elseIf (image.name)
            img = VMGImage( tile, "$-$"(image.name,seq.format(fmt)) )
          else
            img = VMGImage( tile, seq.format(fmt) )
          endIf
          VMGImageList.insert( img, index )
        endForEach
      endForEach

      VMGImageList.remove( VMGImageList.selected )
      VMGImageList.select( index )

endClass

class VMGCmdStack( n:Int32 ) : VMGCmd
  METHODS
    method update_status
      use status = VMGStatusBar
        if (n != 2) status.print n
        status.print "t (stack images)"
        if (VMGImageList.selected)
          local available = VMGImageList.count - VMGImageList.selected.index
          if (n > available) status.print " [not enough images]"
        else
          status.print " [no images]"
        endIf
      endUse

    method execute
      local available : Int32
      if (VMGImageList.selected)
        available = VMGImageList.count - VMGImageList.selected.index
      endIf
      if (n <= 1 or available < n) return

      local bitmap = VMGImageList.selected.image.bitmap

      use list = WorkList<<VMGImage>>
        loop (n)
          local index = VMGImageList.selected.index
          list.add( VMGImageList.selected.image )
          VMGImageList.remove( VMGImageList.selected )
          if (index < VMGImageList.count)
            VMGImageList.select( index )
          elseIf (VMGImageList.count > 0)
            VMGImageList.select( VMGImageList.last_child->(as VMGImageListItem) )
            escapeLoop
          else
            VMGImageList.select( null )
            escapeLoop
          endIf
        endLoop

        local largest_width  = Best<<Int32>>( (a,b) => a > b )
        local largest_height = Best<<Int32>>( (a,b) => a > b )
        largest_width.consider( (forEach in list).bitmap.width )
        largest_height.consider( (forEach in list).bitmap.height )
        (forEach in list).bitmap.crop( largest_width.value, largest_height.value, Vimage.anchor, Vimage.bg_color )

        local result = list.remove_first.bitmap
        forEach (image in list)
          result.blit( image.bitmap, 0, 0, BitmapBlitFn.ALPHA )
          result = image.bitmap
        endForEach

        local result_image = VMGImage( result )
        local before_index = which{ VMGImageList.selected:VMGImageList.selected.index || 0 }
        VMGImageList.insert( result_image, before_index )
        VMGImageList.select( result_image )

      endUse

      VMGImageView.mark_modified
endClass

class VMGCmdSwap( a:Int32, b:Int32 ) : VMGCmd
  METHODS
    method update_status
      status = "swap channels $<>$"("bgra"[a],"bgra"[b])

    method execute
      if ((a or b) and VMGImageView.image)
        local bitmap = VMGImageView.image.bitmap

        local a_shift = a * 8
        local b_shift = b * 8
        forEach (color in rewriter=bitmap.pixels.rewriter)
          local a = (color.argb :>>>: a_shift) & 0xFF
          local b = (color.argb :>>>: b_shift) & 0xFF
          local argb = color.argb & !(0xFF:<<:a_shift) & !(0xFF:<<:b_shift)
          argb |= (a :<<: b_shift) | (b :<<: a_shift)
          rewriter.write( Color(argb) )
        endForEach

        VMGImageView.mark_modified
      endIf
endClass

class VMGCmdYY : VMGCmd [singleton]
  METHODS
    method update_status
      if (VMGImageList.selected)
        set_status( "yy (copy image to clipboard)" )
      else
        set_status( "yy [no image to copy]" )
      endIf

    method execute
      if (VMGImageList.selected)
        Vimage.clipboard = VMGImageList.selected->(as VMGImageListItem).image
      endIf
endClass

class VMGCmdYP : VMGCmd [singleton]
  METHODS
    method update_status
      if (VMGImageList.selected)
        set_status( "yp (yank and paste / duplicate)" )
      else
        set_status( "yp [no image to duplicate]" )
      endIf

    method execute
      if (VMGImageList.selected)
        Vimage.clipboard = VMGImageList.selected->(as VMGImageListItem).image

        local bitmap = Vimage.clipboard.bitmap.cloned
        local before_index = VMGImageList.selected.index
        VMGImageList.insert( VMGImage(bitmap), before_index )
        VMGImageList.select( before_index )
      endIf
endClass

